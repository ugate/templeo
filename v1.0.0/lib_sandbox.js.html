<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>lib/sandbox.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  <!-- https://realfavicongenerator.net/ -->
  
    <link
      
      rel="apple-touch-icon" 
      
      sizes="180x180" 
      
      href="apple-touch-icon.png" 
      
    >
  
    <link
      
      rel="icon" 
      
      type="image/png" 
      
      sizes="32x32" 
      
      href="favicon-32x32.png" 
      
    >
  
    <link
      
      rel="icon" 
      
      type="image/png" 
      
      sizes="16x16" 
      
      href="favicon-16x16.png" 
      
    >
  
    <link
      
      rel="manifest" 
      
      href="site.webmanifest" 
      
    >
  
    <link
      
      rel="mask-icon" 
      
      type="image/png" 
      
      sizes="16x16" 
      
      href="safari-pinned-tab.svg" 
      
      color="#ffab40" 
      
    >
  
    <link
      
      type="text/css" 
      
      rel="stylesheet" 
      
      href="pkg-styles/pkg-style.css" 
      
    >
  

  
    <meta
      
      name="msapplication-TileColor" 
      
      content="#ffab40" 
      
    >
  
    <meta
      
      name="theme-color" 
      
      content="#bdbdbd" 
      
    >
  
    <meta
      
      name="viewport" 
      
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" 
      
    >
  

  <link type="text/css" rel="stylesheet" href="jsdocp/styles/index.css"></head>
<body><div id="jsdocpNav" class="jsdocp-remove-me pkg-menu"
  data-jsdocp-sm-position="bottom"
  data-jsdocp-md-position="bottom"
  data-jsdocp-lg-position="top"
  data-jsdocp-sm-match-media="(max-width: 480px)"
  data-jsdocp-md-match-media="(min-width: 481px) and (max-width: 839px)"
  data-jsdocp-lg-match-media="(min-width: 840px)"
  data-jsdocp-sm-auto-hide="true"
  data-jsdocp-md-auto-hide="true"
  data-jsdocp-lg-auto-hide="false">
  <a href="index.html" id="jsdocpLogo"
    title="templeo"
    class="jsdocp-logo ">
    <b class="pkg-logo">
    
      <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg viewBox="0 0 64 64" width="64" height="64" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <g transform="matrix(1.9935723,0,0,2.0019177,0.08877553,-0.18261032)">
    <g transform="scale(0.96670978,1.0344366)">
      <path d="m 18.634766,5.4023438 c -1.733459,-10e-8 -3.228867,0.5041519 -4.361328,1.5253906 -1.122892,1.0122398 -1.705079,2.3995654 -1.705079,3.9902346 0,0.759851 0.195452,1.57394 0.558594,2.453125 a 0.65860366,0.65860366 0 0 0 0.0039,0.0059 c 0.1107,0.261137 0.17007,0.433699 0.242188,0.626953 -0.412293,-0.119387 -0.811529,-0.335937 -1.234375,-0.335937 -0.57709,0 -1.150057,0.112763 -1.708984,0.326172 a 0.65860366,0.65860366 0 0 0 -0.0059,0.002 c -1.1883607,0.467219 -2.0975223,1.32863 -2.6171874,2.490234 l 0.00195,0 c -0.2754091,0.612021 -0.4199219,1.244178 -0.4199219,1.878906 0,0.586308 0.1172738,1.166119 0.34375,1.722657 2.469e-4,6.06e-4 -2.472e-4,0.0013 0,0.002 0.4616675,1.174144 1.1678027,2.049935 2.1289062,2.474609 a 0.65860366,0.65860366 0 0 0 0.00781,0.0039 c 0.8286494,0.352413 1.5586814,0.548829 2.2304684,0.548829 0.586313,0 1.170378,-0.116216 1.740235,-0.339844 1.181788,-0.458451 2.082653,-1.322653 2.601562,-2.488282 0.330502,-0.705376 0.488282,-1.498294 0.488282,-2.353515 0,-0.214294 -0.0234,-0.559044 -0.06836,-1.134766 -0.04332,-0.676666 -0.248075,-1.447023 -0.591797,-2.357422 a 0.65860366,0.65860366 0 0 0 -0.0039,-0.01367 c -0.215809,-0.535206 -0.423732,-1.120249 -0.625,-1.75 -0.190291,-0.60397 -0.279297,-1.133312 -0.279297,-1.585938 0,-1.026584 0.278067,-1.7499346 0.820313,-2.3066406 a 0.65860366,0.65860366 0 0 0 0.002,-0.00195 c 0.542177,-0.5638645 1.235121,-0.8457031 2.236328,-0.8457031 1.04226,0 1.792542,0.302684 2.402344,0.9199219 a 0.65860366,0.65860366 0 0 0 0.0039,0.00195 c 0.606572,0.606572 0.90625,1.3689279 0.90625,2.4335939 0,1.572702 -0.589605,3.408904 -1.837891,5.498047 a 0.65860366,0.65860366 0 0 0 -0.002,0 c -1.320121,2.215588 -2.011719,4.290309 -2.011719,6.228515 0,1.135656 0.404802,2.137499 1.199219,2.810547 a 0.65860366,0.65860366 0 0 0 0.0039,0.0039 c 0.75835,0.631956 1.698343,0.957031 2.716797,0.957031 1.227821,0 2.438439,-0.64332 3.644531,-1.773438 a 0.65860366,0.65860366 0 0 0 0.03711,-0.921875 L 24.611328,23.130859 A 0.65860366,0.65860366 0 0 0 23.6875,23.078125 c -0.83238,0.732494 -1.487863,1.012762 -1.851562,1.015625 -0.490025,-0.0128 -0.768941,-0.128804 -0.923829,-0.271484 -0.154694,-0.142502 -0.25969,-0.35908 -0.27539,-0.78711 0.0033,-1.431752 0.595963,-3.259206 1.855469,-5.439453 1.332579,-2.306741 2.033203,-4.364066 2.033203,-6.207031 -10e-7,-1.7094646 -0.553007,-3.1902892 -1.650391,-4.2988282 -1.096122,-1.1162349 -2.559684,-1.6875 -4.240234,-1.6875 z M 12.125,16.433594 c 0.207579,0 0.558685,0.07879 1.007812,0.279297 a 0.65860366,0.65860366 0 0 0 0.0039,0.002 c 0.325823,0.142905 0.588789,0.418207 0.804687,0.976562 a 0.65860366,0.65860366 0 0 0 0.002,0.0059 c 0.09694,0.242349 0.140625,0.469511 0.140625,0.695312 0,0.206742 -0.07961,0.56478 -0.279296,1.021484 -1.7e-4,3.8e-4 -0.0018,-3.79e-4 -0.002,0 -0.141144,0.315308 -0.416373,0.578316 -0.976562,0.794922 -0.255126,0.09921 -0.487088,0.142578 -0.712891,0.142578 -0.211018,0 -0.561402,-0.07771 -1.003906,-0.265624 -0.303312,-0.138564 -0.572345,-0.422337 -0.798828,-0.996094 -0.09779,-0.252742 -0.142578,-0.486321 -0.142578,-0.710938 0,-0.21264 0.07548,-0.556983 0.265625,-0.99414 9.3e-5,-2.15e-4 0.0019,2.15e-4 0.002,0 0.141518,-0.316151 0.419067,-0.583253 0.982422,-0.808594 0.243294,-0.09732 0.47252,-0.142578 0.707031,-0.142578 z" />
    </g>
    <g transform="scale(0.805326,1.2417332)">
      <path d="m 29.052173,23.815766 0.951868,0 q 1.903736,0 2.474857,-0.584719 0.584719,-0.584719 0.584719,-2.529249 l 0,-3.372332 q 0,-2.121306 0.611915,-3.086772 0.611915,-0.965466 2.121306,-1.332615 -1.509391,-0.339953 -2.121306,-1.305419 -0.611915,-0.965466 -0.611915,-3.1003697 l 0,-3.3723321 q 0,-1.9309321 -0.584719,-2.515651 -0.571121,-0.598317 -2.474857,-0.598317 l -0.951868,0 0,-1.9445302 0.856682,0 q 3.38593,0 4.514573,1.0062604 1.142242,0.9926623 1.142242,3.9978453 l 0,3.2635472 q 0,2.0261191 0.734298,2.8148091 0.734298,0.775093 2.66523,0.775093 l 0.843083,0 0,1.94453 -0.843083,0 q -1.930932,0 -2.66523,0.788691 -0.734298,0.78869 -0.734298,2.842005 l 0,3.249949 q 0,3.005183 -1.142242,4.011444 -1.128643,1.00626 -4.514573,1.00626 l -0.856682,0 0,-1.958128 z" />
    </g>
    <g transform="scale(0.80532598,1.2417332)">
      <path d="m 10.700812,23.861077 0,1.958128 -0.8430829,0 q -3.3859302,0 -4.5417698,-1.00626 -1.1422415,-1.006261 -1.1422415,-4.011444 l 0,-3.249949 q 0,-2.053315 -0.7342981,-2.842005 -0.7342982,-0.788691 -2.66523025,-0.788691 l -0.82948492,0 0,-1.94453 0.82948492,0 q 1.94453025,0 2.66523025,-0.775093 0.7342981,-0.78869 0.7342981,-2.8148091 l 0,-3.2635472 q 0,-3.0051831 1.1422415,-3.9978453 1.1558396,-1.00626042 4.5417698,-1.00626042 l 0.8430829,0 0,1.94453022 -0.9246715,0 q -1.917334,0 -2.5020529,0.598317 -0.5847189,0.598317 -0.5847189,2.5156509 l 0,3.3723321 q 0,2.1349038 -0.6255132,3.1003698 -0.6119151,0.965466 -2.1077075,1.305419 1.5093905,0.367149 2.1213056,1.332615 0.6119151,0.965466 0.6119151,3.086772 l 0,3.372332 q 0,1.917334 0.5847189,2.515651 0.5847189,0.598317 2.5020529,0.598317 l 0.9246715,0 z" />
    </g>
  </g>
</svg>

    
    </b>
    <b id="jsdocpPkgName">templeo</b>
    <b>|</b>
    <hr/>
  </a>
  <a href="https://www.npmjs.com/package/templeo" id="jsdocpModule"
    title="npm"
    class="jsdocp-icon ">
    
    <svg version="1.1" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
      <g class="jsdocp-icon-svg-el pkg-icons" stroke="none" transform="translate(0,24) scale(0.1,-0.1)">
        <path d="M 0,120 0,0 l 120,0 120,0 0,120 0,120 -120,0 -120,0 z m 200,0 c 0,-73 0.23256,-80 0.23256,-80 0,0 -27.97435,0.741211 -40.61273,0.707427 C 159.61983,67.551504 160,70.949947 160,100 c 0,53 -2,60 -20,60 -18,0 -20,-7 -20,-60 l 0,-60 -40,0 -40,0 0,80 0,80 80,0 80,0 z"/>
      </g>
    </svg>
    
  </a>
  <a href="CHANGELOG.html" id="jsdocpChangelog" data-jsdocp-root-href="https://github.com/ugate/templeo/CHANGELOG.html"
    title="Changelog"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 64 64" height="64" width="64" xmlns="http://www.w3.org/2000/svg">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="M 29.896194,0.97873581 C 13.435048,0.97873581 1.1072664e-7,15.139296 0,32.489368 0,49.839439 13.435048,64 29.896194,64 46.357339,64 59.792385,49.839438 59.792388,32.489368 a 4.2273908,4.4556761 0 1 0 -8.453721,0 c -10e-7,12.534501 -9.550175,22.600399 -21.442473,22.600399 -11.892299,0 -21.4424739,-10.065899 -21.4424739,-22.600399 0,-12.5345 9.5501749,-22.6003988 21.4424739,-22.6003988 a 4.2273908,4.4556761 0 1 0 0,-8.91023339 z" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 55.529412,24.680907 -8.470588,10.142582 16.941176,0 z"/>
      <rect class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        transform="matrix(0.6882785,0.72544656,-0.6882785,0.72544656,0,0)" y="-38.592953" x="38.592953" height="39.814472" width="11.375563" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 23.705056,39.295314 8.338477,-1.11407 -7.281487,-7.674698 z"/>
    </svg>
    
  </a>
  <a href="https://github.com/ugate/templeo#readme" id="jsdocpSourceCode"
    title="Source Code"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 10 16" width="24" height="24" xmlns="http://www.w3.org/2000/svg" id="jsdocpSourceIcon">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="evenodd"
        d="M8 1a1.993 1.993 0 0 0-1 3.72V6L5 8 3 6V4.72A1.993 1.993 0 0 0 2 1a1.993 1.993 0 0 0-1 3.72V6.5l3 3v1.78A1.993 1.993 0 0 0 5 15a1.993 1.993 0 0 0 1-3.72V9.5l3-3V4.72A1.993 1.993 0 0 0 8 1zM2 4.2C1.34 4.2.8 3.65.8 3c0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm3 10c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm3-10c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2z"></path>
    </svg>
    <!-- GitHub icon -->
    <svg version="1.1" viewBox="0 0 16 16" height="24" width="24" xmlns="http://www.w3.org/2000/svg" class="jsdocp-remove-me" id="jsdocpGithubIcon">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none"  fill-rule="evenodd"
        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
    </svg>
    
  </a>
  <!-- versions.json should point to the latest list -->
  <a id="jsdocpVersionsIcon"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 64 64" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 63.999999,25.315556 -24.108295,0 9.74288,-10.026667 C 39.927261,5.6888885 24.210644,5.3333335 14.503322,14.933333 c -9.7073234,9.635555 -9.7073234,25.173334 0,34.808888 9.707322,9.635556 25.423939,9.635556 35.131262,0 4.835883,-4.764443 7.253823,-10.346666 7.253823,-17.386666 l 7.111592,0 c 0,7.039999 -3.1291,16.177777 -9.387301,22.364444 -12.480844,12.373334 -32.748879,12.373334 -45.2297224,0 -12.445286,-12.337778 -12.55196,-32.39111 -0.071116,-44.7288881 12.4808434,-12.3377774 32.4999734,-12.3377774 44.9808174,0 L 64,-5e-7 64,25.315556 Z" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 33.775734,17.777777 0,15.111111 12.445286,7.395556 -2.560173,4.302222 -15.218806,-9.031112 0,-17.777777 5.333693,0 z" />
    </svg>
    
  </a>
  <select id="jsdocpVersions"
    title="v1.0.0"
    data-jsdocp-version-base="/templeo"
    data-jsdocp-json-url="/templeo/versions.json"
    data-jsdocp-type=""
    data-jsdocp-from="1.0.0"
    data-jsdocp-version="1.0.0">
  </select>
</div>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Tutorials</li><li class="nav-item"><a href="tutorial-1-basics.html">The Basics</a></li><li class="nav-item"><a href="tutorial-2-cache.html">Cache</a></li><li class="nav-item"><a href="tutorial-3-examples.html">Examples</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Cachier.html">Cachier</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#.contentURL">contentURL</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#.waiter">waiter</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#clear">clear</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#compile">compile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#getRegistered">getRegistered</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#modules">modules</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#read">read</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#readWriteName">readWriteName</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#register">register</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#registerHelper">registerHelper</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#registerPartial">registerPartial</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#unregister">unregister</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#write">write</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="CachierDB.html">CachierDB</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierDB.html#clear">clear</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierDB.html#compile">compile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierDB.html#read">read</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierDB.html#register">register</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierDB.html#write">write</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="CachierFiles.html">CachierFiles</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierFiles.html#clear">clear</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierFiles.html#compile">compile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierFiles.html#read">read</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierFiles.html#register">register</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierFiles.html#write">write</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-templeo_options-TemplateOpts.html">TemplateOpts</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo_options-TemplateOpts.html#.defaultOptionMerge">defaultOptionMerge</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo_options-TemplateOpts.html#build">build</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-templeo-Engine.html">Engine</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#.create">create</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#clearCache">clearCache</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#compile">compile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#getRegistered">getRegistered</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#register">register</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#registerHelper">registerHelper</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#registerPartial">registerPartial</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#renderPartial">renderPartial</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#renderPartialGenerate">renderPartialGenerate</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#unregister">unregister</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Sandbox.html">Sandbox</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sandbox.html#.compile">compile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sandbox.html#.deserialzeBlock">deserialzeBlock</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sandbox.html#.deserialzeFunction">deserialzeFunction</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sandbox.html#.guid">guid</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sandbox.html#.serialzeFunction">serialzeFunction</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="TemplateDBOpts.html">TemplateDBOpts</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="TemplateFileOpts.html">TemplateFileOpts</a></span></li><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-templeo.html">templeo</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-templeo_options.html">templeo/options</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">lib/sandbox.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

// TODO : ESM remove the following lines...
const TemplateOpts = require('./template-options');
const Director = require('./director');
// TODO : ESM uncomment the following lines...
// TODO : import * as TemplateOpts from './template-options.mjs';
// TODO : import * as Director from './director.mjs';

const FUNC_NAME_REGEXP = /[^\da-zA-Z]/g, FUNC_MAX_LOG = 500;

/**
 * A locally sandboxed/isolated environment within a single VM instance
 */
class Sandbox {
  // TODO : ESM use... export class Sandbox {

  /**
   * Compiles a locally sandboxed `async` template rendering function
   * @param {String} [name] The name given to the template (omit to generate via {@link Sandbox.guid})
   * @param {String} [template] The template content that will be used by the renderer. Omit to load the template from cache.
   * @param {TemplateOpts} [compileOpts] The {@link TemplateOpts}
   * @param {Object} [namers] One or more functions responsible for formatting template names into a full path name
   * that is consumable by `read`/`write`.
   * Each function accepts the following arguments:
   * 1. _{Object}_ `namers` An object that contains a property for each available naming function.
   * 1. _{String}_ `partialName` The name of the partial that will be converted into a name suitable for a read operation.
   * 1. _{(TemplateOpts | Function(name:String):*)}_ `optional` Either the {@link TemplateOpts} or a function that takes a single name
   * argument and returns the option value.
   * 1. _{URLSearchParams}_ `[params]` The URLSearchParams that should be used in the converted name.
   * 1. _{Object}_ `storage` The storage object that can contain metadata used by naming operations.
   * 1. _{Boolean}_ `forContent` The flag indicating if the converted name is being used to capture partials.
   * 1. _{String}_ `extension` The file extension override for the converted name (omit to use the default extension set in the options).
   * 1. _{Boolean}_ `forContext` The flag indicating if the converted name is being used to capture context.
   * @param {Function} [namers.namer] The default naming function that will be used.
   * @param {Function} [namers.namerSuper]  The naming function to use when a `operations[].read` function throws an error. The next
   * reader called in the `operations[]` list will use the name generated by this reader.
   * @param {Object[]} [operations] One or more functions and/or objects that will handle render-time read/write operations.
   * @param {Function} [operations[].read] The reader is an `async function` responsible for reading partial template content/modules/etc
   * during render-time when a partial template cannot be found within `includes`. When `options.cacheRawTemplates` is _truthy_ an
   * attempt will be made to add any missing/read partials into `storage.data` in order to prevent unnecessary template partial
   * reads for repeated includes. Read functions should not reference any external scope other than the global object space.
   * The following arguments will be passed:
   * 1. _{String}_ `name` The name of the partial that will be read. The read function may be invoked without a _name_ parameter when
   * the intent is to capture all partials in a single read opteration that will be included.
   * 1. _{String}_ `path` The path to the partial that will be read. The read function may be invoked without a _path_ parameter when
   * the intent is to capture all partials in a single read opteration that will be included.
   * 1. _{String}_ `ext` The path file extension to the partial that will be read. The read function may be invoked without an _ext_
   * parameter when the intent is to capture all partials in a single read opteration that will be included.
   * 1. _{Boolean}_ `forContent` The flag indicating that the read is for content. Otherwise, the read is for rendering functions.
   * 1. _{(TemplateOpts | Function(name:String):*)}_ `optional` Either the {@link TemplateOpts} or a function that takes a single name
   * argument and returns the option value.
   * 1. _{URLSearchParams}_ `[params]` The URLSearchParams that should be used during the read
   * 1. _{Object}_ `storage` The storage object that can contain metadata for read operations and should contain a __data__ object
   * that stores each of the read paratial template content/metadata.
   * 1. _{Function}_ `[formatter]` The function that will format reads/writes during include discovery (if any). The formatting function
   * takes 1 or 2 arguments with the first being the content that will be formatted and the second being `options.readFormatOptions` for
   * reads and `options.writeFormatOptions` for writes.
   * The returned result should be a valid string.
   * 1. _{Boolean}_ `[close]` A flag indicating whether or not any resources used during the read should be closed/cleaned up after the
   * read completes. Closure may be dependent upon the policy set on the options.
   * 1. _{Object}_ `[log]` A logger that can contain functions for each of the following: `error`/`warn`/`info`/`debug`.
   * 
   * Read functions can return the partial template content and/or it can be set on the `storage.data`.
   * Returning `true` will stop any further rendering from processing resulting in the rendering function returning a _blank_ string.
   * @param {Function} [operations[].write] The write function that will be used for writting newly discovered template sources.
   * Accepts the same arguments as `operations[].read` and all _scoped_ functions will be available. Can return a __rendering__
   * function that will prevent further iteration of any subsequent `operations[].write` invocations.
   * @param {Function} [operations[].finish] An `async function` that can perform cleanup tasks for a reader.  Arguments passed are
   * `storage`, `optional` and `log` as described for `operations[].read`.
   * __after rendering has completed__. Arguments passed are `storage`, `optional` and `log` as described for `operations[].read`. All
   * functions defined within `operations[].scopes` will be available by name.
   * @param {Function[]} [operations[].scopes] Zero or more functions that will be in scope when the read function is called.
   * Scoped functions can assit with complex read/write that can benefit from separate supporting functions. For example, `[myFunc(){}]`
   * could be referenced like `async function myReader(){ myFunc(); ... }`.
   * @param {Director} [director] The {@link Director} that will be for extracting {@link Director.directives}
   * @param {Object} [store] The private storage set during compilation that will be passed during naming/reads. Contents should only
   * contain __valid JSON__ properties that can be serialized/deserialized.
   * @param {Object} [store.data] The cached partials that can be included in the template with the name of the template as a
   * property of the object
   * @param {String} [store.data[].name] The name of the partial template
   * @param {String} [store.data[].content] The partial template content
   * @param {Object} [store.data[].params] The parameters that will be added to scope when the template is parsed
   * @param {Object} [log] The log flags that will determine what output will be sent to the `console` (if any) during rendering
   * @param {Boolean} [log.debug] `true` to output `console.debug` level log
   * @param {Boolean} [log.info] `true` to output `console.info` level log
   * @param {Boolean} [log.warn] `true` to output `console.warn` level log
   * @param {Boolean} [log.error] `true` to output `console.error` level log
   * @returns {Function} The rendering `async function` that returns a template result string based upon the provided context.
   * The following arguments apply:
   * 1. _{Object}_ `context` The context JSON that can be used as data during rendering
   * 1. _{TemplateOpts}_ `[renderOptions]` The rendering options that will superceed any __compile-time__ options
   * 1. _{Function}_ `[readFormatter]` The function that will format read partials during include discovery (if any). The
   * formatting function takes 1 or 2 arguments with the first being the content that will be formatted and the second being
   * the `options.readFormatOptions`. The returned result should be a valid string.
   * 1. _{Function}_ `[writeFormatter]` The function that will format written sources during include discovery (if any). The
   * formatting function takes 1 or 2 arguments with the first being the content that will be formatted and the second being
   * the `options.writeFormatOptions`. The returned result should be a valid string.
   * 1. _{Object}_ `[sharedStore]` An object used for _in-memory_ storage space that can be shared between rendering functions.
   * This ensures that updated data within a renderer execution will be retained between rendering calls from the same renderer
   * or different renderers that are passed the same _shared store_.
   */
  static compile(name, template, compileOpts, namers, operations, director, store, log) {
    const copts = compileOpts instanceof TemplateOpts ? compileOpts : new TemplateOpts(compileOpts);
    const named = (name &amp;&amp; name.replace(FUNC_NAME_REGEXP, '_')) || `template_${Sandbox.guid(null, false)}`;
    const directives = codedDirectives(director);
    const code = coded(named, template, copts, directives, FUNC_NAME_REGEXP, namers, operations, {
      debug: log &amp;&amp; !!log.debug, info: log &amp;&amp; !!log.info, warn: log &amp;&amp; !!log.warn,
      error: log &amp;&amp; !!log.error
    }, null, store);
    return Sandbox.deserialzeBlock(code, named, true);
  }

  /**
   * Deserialzes a function string within a locally sandboxed environment (only global variables are accessible)
   * @param {String} functionString The function string to deserialize
   * @returns {Function|null} The deserialized function
   */
  static deserialzeFunction(functionString) {
    if (functionString &amp;&amp; typeof functionString === 'string') {
      try {
        return (new Function(`return ${functionString}`))();
      } catch (err) {
        err.message += ` &lt;- Unable to deserialize function string: `
        + (functionString.length &lt; FUNC_MAX_LOG ? functionString : `${functionString.substring(0, FUNC_MAX_LOG)}...`);
        throw err;
      }
    }
  }

  /**
   * Deserialzes a code block iwthin a locally sandboxed environment (only global variables are accessible)
   * @param {(String | Function)} block The code block to deserialize
   * @param {String} [name] A name that will be given to the function
   * @param {Boolean} [isAsync] `true` when the function is `async`
   * @returns {(Function | undefined)} The deserialized function
   */
  static deserialzeBlock(block, name, isAsync) {
    const type = typeof block;
    if (block &amp;&amp; (type === 'string' || type === 'function')) {
      if (type === 'function') { // convert function into iife formatted function block
        block = `return (${block.toString()})()`;
      }
      const named = name &amp;&amp; name.length ? ` ${name.replace(FUNC_NAME_REGEXP, '_')}` : '';
      // pass require (when present) since it may be hidden from the block scope
      const rqr = typeof require !== 'undefined' ? require : undefined;
      const rqrd = rqr ? `const require=arguments[0];` : '';
      const code = `${rqrd}return ${isAsync ? 'async ' : ''}function${named}(){ ${block}; }`;
      try {
        //const func = new Function(code);
        //if (named) Object.defineProperty(rtn.func, 'name', { value: named });
        //return named ? { [named](...args) { return func(...args); } }[named] : func;
        // could also use ES2017 new AsyncFunction(...)
        return (new Function(code))(rqr);
      } catch (err) {
        err.message += ` &lt;- Unable to deserialize code on name: "${name || ''}" for:\n`
        + (code.length &lt; FUNC_MAX_LOG ? code : `${code.substring(0, FUNC_MAX_LOG)}...`);
        throw err;
      }
    }
  }

  /**
   * Serialzes a function
   * @param {Function} func The function to serialize
   * @returns {String|null} The serialized function
   */
  static serialzeFunction(func) {
    return func &amp;&amp; typeof func === 'function' ? func.toString() : null;
  }

  /**
  * Generates a GUID or formats an existing `value`
  * @param {String} [value] when present, will format the value by add any missing hyphens (if `hyphenate=true`)
  * instead of generating a new value
  * @param {Boolean} [hyphenate=true] true to include hyphens in generated result
  * @returns {String} the generated GUID
  */
  static guid(value, hyphenate = true) {
    const hyp = hyphenate ? '-' : '';
    if (value) return hyphenate ? value.replace(/(.{8})-?(.{4})-?(.{4})-?(.{4})-?(.{12})/gi, `$1${hyp}$2${hyp}$3${hyp}$4${hyp}$5`) : value;
    return `xxxxxxxx${hyp}xxxx${hyp}4xxx${hyp}yxxx${hyp}xxxxxxxxxxxx`.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r &amp; 0x3 | 0x8);
      return v.toString(16);
    });
  }

  /**
   * @returns {Object} The global object. Typically, `window` when ran within a browser or `global` when ran on a server
   */
  static get global() {
    return (function globalize(){ return this; })();
  }
}

// TODO : ESM remove the following lines...
module.exports = Sandbox;

/**
 * Manufactures directives/functions that will be available to template lierals during rendering
 * @private
 * @param {Director} [director] The {@link Director} that will be for extracting {@link Director.directives}
 * @returns {Object} The `{ names:String, code:String }` where `names` is a string representation of the directive
 * names (in array format) and `code` represents the commulative coded functions
 */
function codedDirectives(director) {
  if (!(director instanceof Director)) {
    throw new Error(`Expected ${Director.name}, but found ${director}`);
  }
  const directives = director.directives;
  const rtn = { names: '', code: '' };
  for (let drv of directives) {
    rtn.code += `${drv.code.toString()}`;
    rtn.names += (rtn.names ? ',' : '') + drv.name;
  }
  rtn.names = `[${rtn.names}]`;
  return rtn;
}

/**
 * Generates a locally sandboxed environment compilation for template rendering
 * @private
 * @param {String} name A sanitized name given to the template
 * @param {String} [template] The template content that will be used by the renderer. Omit to load the template from cache.
 * @param {Object} includes The cached partials that can be included in the template with the name of
 * the template as a property of the object
 * @param {String} includes[].name The name of the partial template
 * @param {String} includes[].content The partial template content
 * @param {TemplateOpts} compileOpts The {@link TemplateOpts}
 * @param {Object} directives A return object from {@link codedDirectives}
 * @param {RegExp} nameRegExp The regular expression that will replace invalid characters when naming rendering functions
 * @param {Object} [namers] One or more functions responsible for formatting template names into a full path name
 * that is consumable by `read`/`write`.
 * Each function accepts the following arguments:
 * 1. _{Object}_ `namers` An object that contains a property for each available naming function.
 * 1. _{String}_ `partialName` The name of the partial that will be converted into a name suitable for a read operation.
 * 1. _{String}_ `path` The full name/path for the partial returned from a __namer__ function.
 * 1. _{(TemplateOpts | Function(name:String):*)}_ `optional` Either the {@link TemplateOpts} or a function that takes a single name
 * argument and returns the option value.
 * 1. _{URLSearchParams}_ `[params]` The URLSearchParams that should be used in the converted name.
 * 1. _{Object}_ `storage` The storage object that can contain metadata used by naming operations.
 * 1. _{Boolean}_ `forContent` The flag indicating if the converted name is being used to capture partials.
 * 1. _{String}_ `extension` The file extension override for the converted name (omit to use the default extension set in the options).
 * 1. _{Boolean}_ `forContext` The flag indicating if the converted name is being used to capture context.
 * @param {Function} [namers.namer] The default naming function that will be used.
 * @param {Function} [namers.namerSuper]  The naming function to use when a `operations[].read` function throws an error. The next
 * reader called in the `operations[]` list will use the name generated by this reader.
 * @param {Object[]} [operations] One or more functions and/or objects that will handle render-time read/write operations.
 * @param {Function} [operations[].read] The reader is an `async function` responsible for reading partial template content/modules/etc
 * during render-time when a partial template cannot be found within `includes`. When `options.cacheRawTemplates` is _truthy_ an
 * attempt will be made to add any missing/read partials into `storage.data` in order to prevent unnecessary template partial
 * reads for repeated includes. Read functions should not reference any external scope other than the global object space.
 * The following arguments will be passed:
 * 1. _{String}_ `name` The name of the partial that will be read. The read function may be invoked without a _name_ parameter when
 * the intent is to capture all partials in a single read opteration that will be included.
 * 1. _{String}_ `path` The path to the partial that will be read. The read function may be invoked without a _path_ parameter when
 * the intent is to capture all partials in a single read opteration that will be included.
 * 1. _{String}_ `ext` The path file extension to the partial that will be read. The read function may be invoked without an _ext_
 * parameter when the intent is to capture all partials in a single read opteration that will be included.
 * 1. _{Boolean}_ `forContent` The flag indicating that the read is for content. Otherwise, the read is for rendering functions.
 * 1. _{(TemplateOpts | Function(name:String):*)}_ `optional` Either the {@link TemplateOpts} or a function that takes a single name
 * argument and returns the option value.
 * 1. _{URLSearchParams}_ `[params]` The URLSearchParams that should be used during the read
 * 1. _{Object}_ `storage` The storage object that can contain metadata for read operations and should contain a __data__ object
 * that stores each of the read paratial template content/metadata.
 * 1. _{Function}_ `[formatter]` The function that will format reads/writes during include discovery (if any). The formatting function
 * takes 1 or 2 arguments with the first being the content that will be formatted and the second being `options.readFormatOptions` for
 * reads and `options.writeFormatOptions` for writes.
 * The returned result should be a valid string.
 * 1. _{Boolean}_ `[close]` A flag indicating whether or not any resources used during the read should be closed/cleaned up after the
 * read completes. Closure may be dependent upon the policy set on the options.
 * 1. _{Object}_ `[log]` A logger that can contain functions for each of the following: `error`/`warn`/`info`/`debug`.
 * 
 * Read functions can return the partial template content and/or it can be set on the `storage.data`.
 * Returning `true` will stop any further rendering from processing resulting in the rendering function returning a _blank_ string.
 * @param {Function} [operations[].write] The write function that will be used for writting newly discovered template sources.
 * Accepts the same arguments as `operations[].read` and all _scoped_ functions will be available. Can return a __rendering__
 * function that will prevent further iteration of any subsequent `operations[].write` invocations.
 * @param {Function} [operations[].finish] An `async function` that can perform cleanup tasks for a reader.  Arguments passed are
 * `storage`, `optional` and `log` as described for `operations[].read`.
 * __after rendering has completed__. Arguments passed are `storage`, `optional` and `log` as described for `operations[].read`. All
 * functions defined within `operations[].scopes` will be available by name.
 * @param {Function[]} [operations[].scopes] Zero or more functions that will be in scope when the read function is called.
 * Scoped functions can assit with complex reads/writes that can benefit from separate supporting functions. For example, `[myFunc(){}]`
 * could be referenced like `async function myReader(){ myFunc(); ... }`.
 * @param {Object} [log] The log flags that will determine what output will be sent to the `console` (if any) during rendering
 * @param {Boolean} [log.debug] `true` to output `console.debug` level log
 * @param {Boolean} [log.info] `true` to output `console.info` level log
 * @param {Boolean} [log.warn] `true` to output `console.warn` level log
 * @param {Boolean} [log.error] `true` to output `console.error` level log
 * @param {Object} [params] The parameters that will be available via the `options.includesParametersName`
 * alias within the scope of the included template
 * @param {Object} [store] The private storage that is passed during naming/reads. Contents should only contain __valid JSON__ properties that
 * can be serialized/deserialized.
 * @param {Object} [storeMeta] The __private__ metadata pertaining to the storage being used
 * @param {Boolean} [storeMeta.hasNoNameInit] `true` when the templates have been initialized meetting the criteria described in {@link _readHandler}
 * @param {Boolean} [storeMeta.finished] `true` when all of the available `operations[].finish` functions have completed execution
 * @param {Object} [metadata] The metadata that describes the template being coded (exposed to the tempalte scope)
 * @param {String} [metadata.name] The name of the template that the current template is being coded for
 * @param {Object} [metadata.parent] The metadata of the template parent to the current one being coded
 * @returns {String} A coded rendering representation to be used in a function body by a template
 * engine. Assumes `arguments[0]` is a `context` object, `arguments[1]` is the rendering options object and `arguments[2]` is a function that
 * will format written sources during include discovery (if any). The formatting function takes 1 or 2 arguments with the first being the content
 * that will be formatted and the second being `options.readFormatOptions` for reads or `options.writeFormatOptions` for writes. 
 */
function coded(name, template, compileOpts, directives, nameRegExp, namers, operations, log, params, store, storeMeta, metadata) {
  const varName = typeof compileOpts.varName === 'string' ? compileOpts.varName : '';
  const tmpl = typeof template === 'string' ? template : `\${ await include\`${optional('defaultTemplateName', compileOpts, {})}\` }`;
  const strFn = (key, val) => val instanceof RegExp ? { class: RegExp.name, source: val.source, flags: val.flags } : val;
  const meta = `const metadata=Object.freeze(${JSON.stringify({ name, parent: metadata })});`;
  const debug = optional('debugger', compileOpts, {}) ? 'debugger;' : '';
  const debugx = log &amp;&amp; log.debug ? typeof log.debug === 'function' ? console.debug === log.debug ? 'console.debug' : log.debug.toString() : 'console.debug' : false;
  const infox = log &amp;&amp; log.info ? typeof log.info === 'function' ? console.info === log.info ? 'console.info' : log.info.toString() : 'console.info' : false;
  const warnx = log &amp;&amp; log.warn ? typeof log.warn === 'function' ? console.warn === log.warn ? 'console.warn' : log.warn.toString() : 'console.warn' : false;
  const errorx = log &amp;&amp; log.error ? typeof log.error === 'function' ? console.error === log.error ? 'console.error' : log.error.toString() : 'console.error' : false;
  const logx = `const log={debug:${debugx},info:${infox},warn:${warnx},error:${errorx}};`;
  let nmrs = typeof namers === 'object' ? namers : {}, namerAdded, nmro, namex = 'const namers=Object.freeze({';
  for (let nmr in nmrs) {
    if (!nmrs.hasOwnProperty(nmr)) continue;
    if (typeof nmrs[nmr] === 'function') {
      nmro = `${nmr}:${nmrs[nmr].toString()}`;
      namex += `${namerAdded ? ',' : ''}${nmro}`;
      namerAdded = true;
    } else throw new Error(`Unable to add naming function: ${nmrs[nmr]}`);
  }
  namex += '});';
  let ops = Array.isArray(operations) ? operations : [operations], opAdded, opx = 'const operations=Object.freeze([';
  const addOp = (op, idx) => {
    const rdf = typeof op.read === 'function' ? op.read : null;
    const wrf = typeof op.write === 'function' ? op.write : function noopWrite() { return Promise.resolve(); };
    const fsh = typeof op.finish === 'function' ? op.finish : null;
    if (!rdf) throw new Error(`"read" operation function at index ${idx} not present for "${op.read}"`);
    const scp = op &amp;&amp; Array.isArray(op.scopes) &amp;&amp; op.scopes.length ? op.scopes : null;
    let opo = '', opScoped = '';
    if (scp) {
      const opNames = [{ name: 'read', func: rdf, num: 1 }, { name: 'write', func: wrf, num: 2 }];
      if (fsh) opNames.push({ name: 'finish', func: fsh, num: 3 });
      for (let sfunc of scp) {
        if (typeof sfunc === 'function' &amp;&amp; sfunc.name) {
          opScoped += `let ${sfunc.name}=${sfunc.toString()};`;
          opScoped += `{let fn=${sfunc.name};for(let sfn of thiz.scopes){if(sfn.name === '${sfunc.name}'){fn=null;break;}}if(fn){thiz.scopes.push(${sfunc.name});}}`
        }
      }
      opo += `scopedOp:function(type,thiz,args){${opScoped} if(typeof type === 'undefined'){return;} `;
      opo += `const _op=type === 1 ? ${rdf.toString()} : type === 2 ? ${wrf.toString()} : ${fsh ? fsh.toString() : '()=>null'};`;
      opo += `return args &amp;&amp; args.length ? _op.apply(undefined, args) : _op;}`;
      for (let ono of opNames) {
        opo += `,get ${ono.name}(){const thiz=this;const ${ono.name}=function ${ono.func.name || ''}(){`;
        opo += `return thiz.scopedOp(${ono.num},thiz,arguments);};`;
        opo += `${ono.name}.toString=() => ${ono.name}().toString();`;
        opo += `return ${ono.name};}`;
      }
      opo += `,scopes:[]`;
    } else {
      opo = `read:${rdf.toString()}`;
      opo += `,write:${wrf.toString()}`;
      if (fsh) opo += `,finish:${fsh.toString()}`;
    }
    opx += `${opAdded ? ',' : ''}Object.freeze({${opo}})`;
    opAdded = true;
  };
  let opi = -1;
  for (let op of ops) addOp(op, ++opi);
  opx += ']);';
  const nmreg = `const nameRegExp=/${nameRegExp.source}/${nameRegExp.flags || ''};`;
  const coptx = `const compileOpts=${JSON.stringify(compileOpts, strFn)};`;
  const roptx = `const renderOpts=typeof arguments[1] === 'object' ? arguments[1] : {};`;
  const frmtx = `const readFormatter=typeof arguments[2] === 'function' ? arguments[2] : null;const writeFormatter=typeof arguments[3] === 'function' ? arguments[3] : null;`;
  const optsx = `const optional=${optional.toString()};`;
  const storex = `const store=${store ? JSON.stringify(store) : '{}'};const storeDta=store.data;store.data=arguments[4] || storeDta || {};`;
  const storedx = `for (let nm in (storeDta !== store.data &amp;&amp; store.data)){if(store.data.hasOwnProperty(nm))continue;store.data[nm]=storeDta.data[nm];};`;
  const storemx = `const storeMeta=${storeMeta ? JSON.stringify(storeMeta) : '{}'};`
  const varx = `const varName='${varName}';`;
  const dirsx = `const directives=${JSON.stringify(directives)};`;
  const sandx = `const renderContent=${renderContent.toString()};const renderRead=${renderRead.toString()};const coded=${coded.toString()};`;
  const inclx = `_readHandler=${_readHandler.toString()};include=${include.toString()};if (await _readHandler()) { return ''; };`;
  // read/load the primary template when not passed into coded and/or context JSON when not passed into the renderer
  const tempx = `ctx=typeof arguments[0] === 'object' ? arguments[0] : null;`;
  const itx = `${tempx}{ const cnm=(!ctx || typeof ctx !== 'object') &amp;&amp; optional('defaultContextName');ctx=cnm ? await renderRead(cnm, true) : ctx; } `;
  const ctx = `const ${varName}=ctx;const context=${varName};ctx=undefined;`;
  const prm = `const ${optional('includesParametersName', compileOpts, {}) || 'params'}=${JSON.stringify(params)};`;
  // privately scoped parameters are isolated in a separate code block to restrict access to just the include
  // function and other private values
  const incl = `let include,ctx,_readHandler; { ${logx}${namex}${opx} { ${nmreg}${coptx}${roptx}${frmtx}${optsx}${storex}${storedx}${storemx}${varx}${dirsx}${sandx}${inclx}${itx} } }`;
  const fnshx = 'await _readHandler(true);';
  const srcurl = optional('useSourceURL', compileOpts, {}) ? `\n//# sourceURL=${name}.js` : '';
  // the context object is contained in a separate code block in order to isolate it from access within directives
  return `${meta}${directives.code}; { ${incl}${ctx}${prm}${debug}const result=\`${tmpl}\`;${fnshx}return result; }${srcurl}\n`;
}

/**
 * Runs through all of the operations and runs any async `finish` tasks
 * __Assumes the following variables are within scope:__
 * - `metadata` - The metadata for exectution
 * - `compileOpts` - The compile options
 * - `renderOpts` - The rendering options
 * - `readFormatter` - The rendering formatting function that will be used when reading partial template content
 * - `writeFormatter` - The rendering formatting function that will be used when writting compiled sources
 * - `optional` - The {@link optional} function
 * - `store` - Miscellaneous storage container
 * - `storeMeta` - The storage metadata
 * - `operations` - One or more async functions that will read partial templates and write included/compiled rendering functions
 * - `log` - The log functions
 * @private
 * @ignore
 * @param {Boolean} [isFinish] `true` when running any `reader.finish` tasks or any other value when calling `reader.read` without a __name__
 * argument on each reader. Once all read operations have been invoked without a __name__ argument, `storeMeta.hasNoNameInit` will be
 * set to __true__.
 * @returns {Boolean} `true` when a `reader.read` returns `true` indicating that the rendering should not continue. `false` for all
 * other scenarios.
 */
async function _readHandler(isFinish) {
  if (storeMeta.stopped) return;
  if (isFinish) {
    if (!metadata.name || storeMeta.finished) return;
    if (metadata.name !== optional('defaultTemplateName')) return;
  }
  for (let op of operations) {
    if (isFinish) {
      if (op.finish) await op.finish(store, optional, log);
    } else {
      if (!storeMeta.hasNoNameInit) {
        try {
          if ((await op.read(null, null, null, true, optional, null, store, readFormatter, true, log)) === true) {
            return (storeMeta.stopped = true);
          }
        } catch (err) {
          err.message += ` &lt;- Failed to initiate reader "${op.read.name}"`;
          throw err;
        }
      }
    }
  }
  if (isFinish) {
    storeMeta.finished = true;
  } else storeMeta.hasNoNameInit = true; // should only int 1x
  return false;
}

/**
 * Returns either the `renderOpts` or the `compileOpts` option value (in that order of precedence). Also converts `RegExp` constructs
 * into regular expressions. For example, `{ class: 'RegExp', source: "a|b", flags: "i" }` will be converted into `/a|b/i`.
 * __Assumes the following variables are within scope:__
 * - `compileOpts` - The compile options
 * - `renderOpts` - The rendering options
 * @private
 * @ignore
 * @param {String} name The name of the option to check for
 * @param {Object} [copts] Compile options override of an in-scope `compileOpts`
 * @param {Object} [ropts] Render options override of an in-scope `renderOpts`
 * @returns {*} The value of the option
 */
function optional(name, copts, ropts) {
  copts = copts || compileOpts;
  ropts = ropts || renderOpts;
  const opts = ropts.hasOwnProperty(name) ? ropts : copts;
  if (opts[name] &amp;&amp; opts[name].class === RegExp.name) {
    opts[name] = new RegExp(opts[name].source, opts[name].flags);
  }
  return opts[name];
}

/**
 * Compiles and renders template content at render-time
 * __Assumes the following variables are within scope:__
 * - `metadata` - The metadata for exectution
 * - `compileOpts` - The compile options
 * - `renderOpts` - The rendering options
 * - `readFormatter` - The rendering formatting function that will be used when reading partial template content
 * - `writeFormatter` - The rendering formatting function that will be used when writting compiled sources
 * - `optional` - The {@link optional} function
 * - `store` - Miscellaneous storage container
 * - `storeMeta` - The storage metadata
 * - `context` - The context object passed into the rendering function
 * - `directives` - The directive/helper functions used in the template (from {@link Director.directives})
 * - `operations` - One or more async functions that will read partial templates and write included/compiled rendering functions
 * - `namers` - An object that contains one or more functions that will compose names that will be passed into read/write operations
 * - `nameRegExp` - The regular expression that will replace invalid characters when naming rendering functions
 * - `coded` - The {@link coded} function
 * - `log` - The log functions
 * @private
 * @ignore
 * @param {String} name The template name
 * @param {String} path The complete path name
 * @param {String} [ext] The path extension
 * @param {String} content The raw, uncompiled template content
 * @param {Object} [params] The parameters that will be available via the `options.includesParametersName`
 * alias within the scope of the included template
 * @param {Boolean} [fromCache] `true` when the content is coming from cache
 * @returns {String} The rendered template content
 */
async function renderContent(name, path, ext, content, params, fromCache) {
  if (!content) content = optional('defaultPartialContent');
  // new Function restricts access to closures (other than globals)
  const block = coded(path, content, compileOpts, directives, nameRegExp, namers, operations, log, params, store, storeMeta, metadata);
  // pass require (when present) since it may be hidden from the block scope
  const rqr = typeof require !== 'undefined' ? require : undefined;
  // optionally "require" can be passed when available
  const rqrd = rqr ? `const require=arguments[0];` : '';
  const named = path.replace(nameRegExp, '_');
  let renderer = new Function(`${rqrd}return async function ${named}(){ ${block}; }`)(rqr);
  if (!fromCache &amp;&amp; ext) {
    const policy = optional('renderTimePolicy');
    if (policy.includes('write')) {
      const isClosePolicy = policy.includes('close'), srcPath = path.replace(new RegExp(`.${ext}$`), '.js');
      let error, nerr, wcnt = 0, writeRenderer;
      for (let op of operations) {
        wcnt++;
        if (!op.write) continue;
        try {
          writeRenderer = await op.write(name, srcPath, 'js', false, optional, params, store, renderer, writeFormatter, isClosePolicy, log);
          if (typeof writeRenderer === 'function') {
            renderer = writeRenderer;
            break;
          }
        } catch (err) {
          nerr = new Error(err.constructor.name !== 'Error' ? `${err.constructor.name || 'SandboxError'}:` : '');
          nerr.code = err.code;
          nerr.stack = `${err.message}${error &amp;&amp; error.message ? ` &lt;- ${error.message}` : ''}`
          + (wcnt >= operations.length ? ` &lt;- Unable to write content via "${op.write.name}" for included template "${name}"`
          + ` using policy "${policy}" (render-time read)`
          : '') + `\nWRITER #${wcnt} of ${operations.length}: ${op.write.name}\n${err.stack}${error ? `\n${error.stack}` : ''}`;
          error = nerr;
        }
      }
      if (error) throw error;
    }
  }
  return renderer(context, renderOpts, readFormatter, writeFormatter);
}

/**
 * Reads a template __content__ or a template __context__ at render-time
 * __Assumes the following variables are within scope:__
 * - `metadata` - The metadata for exectution
 * - `compileOpts` - The compile options
 * - `renderOpts` - The rendering options
 * - `readFormatter` - The rendering formatting function that will be used when reading partial template content
 * - `writeFormatter` - The rendering formatting function that will be used when writting compiled sources
 * - `optional` - The {@link optional} function
 * - `store` - Miscellaneous storage container
 * - `storeMeta` - The storage metadata
 * - `context` - The context object passed into the rendering function
 * - `directives` - The directive/helper functions used in the template (from {@link Director.directives})
 * - `operations` - One or more async functions that will read partial templates and write included/compiled rendering functions
 * - `namers` - An object that contains one or more functions that will compose names that will be passed into read/write operations
 * - `nameRegExp` - The regular expression that will replace invalid characters when naming rendering functions
 * - `coded` - The {@link coded} function
 * - `log` - The log functions
 * - `renderContent` - The {@link renderContent} function
 * @private
 * @param {String} name The template or context name
 * @param {Boolean} [forContext] `true` to read a template __context__ instead of the default read for a template
 * __content__
 * @param {URLSearchParams} [sprms] The key/value parameters to pass into the `operations[].read`
 * @param {Object} [iprms] The parameters that will be available via the `options.includesParametersName`
 * alias within the scope of the included template
 * @param {Boolean} [fromExpression] `true` when the read is from an interpolated expression
 * @returns {(String | Object)} Either the template __content__ or the JSON __context__
 */
async function renderRead(name, forContext, sprms, iprms, fromExpression) {
  let rtn, path;
  try {
    path = await namers.namer(namers, name, optional, sprms, store, true, null, forContext);
  } catch (err) {
    const error = new Error(`${err.message} &lt;- Unable to extract a name for con${forContext ? 'text' : 'tent'} via`
    + ` NAMER: "${namers.namer.name}" for include template @ "${path || name}" (render-time read)`);
    error.stack = err.stack;
    throw error;
  }
  let ext = path &amp;&amp; path.match(/^.*?\.([^/.]+)$/), fromCache;
  ext = ext &amp;&amp; ext[1];
  if (store.data[path] &amp;&amp; store.data[path].hasOwnProperty('content')) {
    if (log &amp;&amp; log.info) log.info(`RENDER:  Found registered "${path}" in memory during pre-read`);
    rtn = store.data[path].content;
    fromCache = true;
  } else if (operations.length &amp;&amp; optional('renderTimePolicy') !== 'none') {
    let error, nerr, rcnt = 0, fnames, policy = optional('renderTimePolicy'), close = policy.includes('close'), rtnType;
    for (let op of operations) {
      try {
        rcnt++;
        rtn = await op.read(name, path, ext ? ext : undefined, true, optional, sprms, store, readFormatter, close, log);
        rtnType = typeof rtn;
        if (rtnType === 'string')  break;
        else if (rtnType === 'object' &amp;&amp; rtn.hasOwnProperty('content')) {
          rtnType = rtn.content &amp;&amp; typeof rtn.content;
          if (rtnType === 'string' || rtnType === 'object') {
            rtn = rtn.content;
            break;
          }
        } else if (store.data[path]) {
          rtnType = store.data[path].content &amp;&amp; typeof store.data[path].content;
          if (rtnType === 'string' || rtnType === 'object') {
            rtn = store.data[path].content;
            break;
          }
        }
        if (rcnt >= operations.length) throw new Error(`Exhausted all ${operations.length} available readers`);
        throw new Error(`Reader "${op.read.name}" returned "${typeof rtn}" rather than an expected content "string"`);
      } catch (err) {
        if (fnames) fnames.push(path);
        else fnames = [path];
        if (typeof namers.namerSuper === 'function') {
          try {
            path = await namers.namerSuper(namers, name, optional, sprms, store, true, null, forContext, path);
            if (store.data[path] &amp;&amp; typeof store.data[path].content === 'string') {
              rtn = store.data[path].content;
              break;
            }
          } catch (nerr) {
            const error = new Error(`${nerr.message} &lt;- Unable to extract a name for con${forContext ? 'text' : 'tent'} via`
            + ` READ ERROR NAMER: "${namers.namerSuper.name}" for include template @ "${path || name}" (render-time read)`);
            error.stack = nerr.stack;
            throw error;
          }
        }
        nerr = new Error(err.constructor.name !== 'Error' ? `${err.constructor.name || 'SandboxError'}:` : '');
        nerr.code = err.code;
        nerr.stack = `${err.message}${error &amp;&amp; error.message ? ` &lt;- ${error.message}` : ''}`
        + (rcnt >= operations.length ? ` &lt;- Unable to read content via "${op.read.name}" for included template "${name}" @`
        + ` reader names: "${fnames.join('" >> "')}"${metadata.parent ? ` under parent "${metadata.parent.name}"` : ''}`
        + ` using policy "${policy}"${err instanceof TypeError ? 
          '. Ensure that a proper URL/path option has been set' : ''} (render-time read)`
        : '') + `\nREADER #${rcnt} of ${operations.length}: ${op.read.name}\n${err.stack}${error ? `\n${error.stack}` : ''}`;
        error = nerr;
      }
      if (error &amp;&amp; rcnt >= operations.length) throw error;
    }
    if (typeof rtn === 'string' &amp;&amp; optional('cacheRawTemplates')) {
      if (log &amp;&amp; log.info) log.info(`RENDER:  Registering "${path}" in memory during rendering`);
      store.data[path] = { name: path, shortName: name, content: rtn, renderTime: true };
    }
  } else if (sprms) {
    const cause = operations.length ? '"options.renderTimePolicy" is set to "none"' : 'no reader function(s) have been defined';
    const detail = `Read refresh required since parameters have been passed to include, but ${cause}. Parameters: ${sprms.toString()} `;
    throw new Error(`Cannot include template @ ${path} (${fromExpression ? 'expression' : 'string'} literal). ${detail}`);
  } else throw new Error(`Cannot find included template @ ${path} (${fromExpression ? 'expression' : 'string'} literal)`);
  if (forContext) {
    if (typeof rtn !== 'object') {
      try {
        rtn = JSON.parse(rtn);
      } catch (err) {
        err.message += ` &lt;- Unable to parse JSON context @ ${path} (render-time read)`;
        throw err;
      }
    }
  } else {
    try {
      rtn = await renderContent(name, path, ext, rtn, iprms, fromCache);
    } catch (err) {
      err.message += ` &lt;- Unable to include template @ ${path} (render-time read)`;
      throw err;
    }
  }
  return rtn;
}

/**
 * Template literal tag that will include partials during the rendering phase.
 * __Assumes the following variables are within scope:__
 * - `metadata` - The metadata for exectution
 * - `compileOpts` - The compile options
 * - `renderOpts` - The rendering options
 * - `readFormatter` - The rendering formatting function that will be used when reading partial template content
 * - `writeFormatter` - The rendering formatting function that will be used when writting compiled sources
 * - `optional` - The {@link optional} function
 * - `store` - Miscellaneous storage container
 * - `storeMeta` - The storage metadata
 * - `varName` - The name of the context variable
 * - `context` - The context object passed into the rendering function
 * - `directives` - The directive/helper functions used in the template (from {@link Director.directives})
 * - `operations` - One or more async functions that will read partial templates and write included/compiled rendering functions
 * - `namers` - An object that contains one or more functions that will compose names that will be passed into read/write operations
 * - `nameRegExp` - The regular expression that will replace invalid characters when naming rendering functions
 * - `coded` - The {@link coded} function
 * - `log` - The log functions
 * - `renderContent` - The {@link renderContent} function
 * - `renderRead` - The {@link renderRead} function
 * @private
 * @param {String[]} strs The string passed into template literal tag that contains the partial template name to include
 * @param  {Array} exps The expressions passed into template literal tag. Each expression can be one of the following:
 * - `String` - A partial template name to include
 * - `Object` - An object that contains properties that will be passed into the read function for each name that appear
 * __at__ or __before__ the same index as the object parameter expression. Parameters are __not__ cumulative. For example,
 * `name1${ { param1: 1 } }name2${ { param2: 2 } }` would imply `name1` would have `param1` while `name2` would __only__
 * have `param2`, __not__ `param1`.
 */
async function include(strs, ...exps) {
  let rtn = '';
  for (let i = 0, ln = Math.max(strs.length, exps.length), str, exp, names, ni, sprms, iprms; i &lt; ln; i++) {
    str = strs[i] &amp;&amp; strs[i].trim();
    exp = exps[i];
    if (str &amp;&amp; exp instanceof URLSearchParams) {
      if (operations.length &amp;&amp; optional('renderTimePolicy') !== 'none') sprms = exp;
      exp = null;
    } else if (str &amp;&amp; exp &amp;&amp; typeof exp === 'object') {
      iprms = exp;
      exp = null;
    }
    if (!str &amp;&amp; !exp &amp;&amp; !sprms &amp;&amp; !iprms) continue;
    names = str &amp;&amp; exp ? [str, exp] : str ? [str] : exp ? [exp] : null;
    if (names) {
      ni = -1;
      for (let name of names) {
        ni++;
        rtn += await renderRead(name, false, sprms, iprms, ni > 0);
      }
    }
    sprms = iprms = null; // parameters do not carry over from one string/expression to the next
  }
  return rtn;
}</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<div id="jsdocpChangelogContent" data-title="CHANGELOG v1.0.0">
  <svg class="jsdocp-close" id="jsdocpChangelogClose" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
  </svg>
  <h2><a href="https://github.com/ugate/templeo/tree/v1.0.0">1.0.0</a> (2019-12-16)</h2>
<p><a href="https://github.com/ugate/templeo/compare/v1.0.0...v1.0.0">Full Changelog</a></p>
</div>



<script src="jsdocp/scripts/index.js"></script></body>
</html>
