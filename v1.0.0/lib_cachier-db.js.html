<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>lib/cachier-db.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  <!-- https://realfavicongenerator.net/ -->
  
    <link
      
      rel="apple-touch-icon" 
      
      sizes="180x180" 
      
      href="apple-touch-icon.png" 
      
    >
  
    <link
      
      rel="icon" 
      
      type="image/png" 
      
      sizes="32x32" 
      
      href="favicon-32x32.png" 
      
    >
  
    <link
      
      rel="icon" 
      
      type="image/png" 
      
      sizes="16x16" 
      
      href="favicon-16x16.png" 
      
    >
  
    <link
      
      rel="manifest" 
      
      href="site.webmanifest" 
      
    >
  
    <link
      
      rel="mask-icon" 
      
      type="image/png" 
      
      sizes="16x16" 
      
      href="safari-pinned-tab.svg" 
      
      color="#ffab40" 
      
    >
  
    <link
      
      type="text/css" 
      
      rel="stylesheet" 
      
      href="pkg-styles/pkg-style.css" 
      
    >
  

  
    <meta
      
      name="msapplication-TileColor" 
      
      content="#ffab40" 
      
    >
  
    <meta
      
      name="theme-color" 
      
      content="#bdbdbd" 
      
    >
  
    <meta
      
      name="viewport" 
      
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" 
      
    >
  

  <link type="text/css" rel="stylesheet" href="jsdocp/styles/index.css"></head>
<body><div id="jsdocpNav" class="jsdocp-remove-me pkg-menu"
  data-jsdocp-sm-position="bottom"
  data-jsdocp-md-position="bottom"
  data-jsdocp-lg-position="top"
  data-jsdocp-sm-match-media="(max-width: 480px)"
  data-jsdocp-md-match-media="(min-width: 481px) and (max-width: 839px)"
  data-jsdocp-lg-match-media="(min-width: 840px)"
  data-jsdocp-sm-auto-hide="true"
  data-jsdocp-md-auto-hide="true"
  data-jsdocp-lg-auto-hide="false">
  <a href="index.html" id="jsdocpLogo"
    title="templeo"
    class="jsdocp-logo ">
    <b class="pkg-logo">
    
      <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg viewBox="0 0 64 64" width="64" height="64" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <g transform="matrix(1.9935723,0,0,2.0019177,0.08877553,-0.18261032)">
    <g transform="scale(0.96670978,1.0344366)">
      <path d="m 18.634766,5.4023438 c -1.733459,-10e-8 -3.228867,0.5041519 -4.361328,1.5253906 -1.122892,1.0122398 -1.705079,2.3995654 -1.705079,3.9902346 0,0.759851 0.195452,1.57394 0.558594,2.453125 a 0.65860366,0.65860366 0 0 0 0.0039,0.0059 c 0.1107,0.261137 0.17007,0.433699 0.242188,0.626953 -0.412293,-0.119387 -0.811529,-0.335937 -1.234375,-0.335937 -0.57709,0 -1.150057,0.112763 -1.708984,0.326172 a 0.65860366,0.65860366 0 0 0 -0.0059,0.002 c -1.1883607,0.467219 -2.0975223,1.32863 -2.6171874,2.490234 l 0.00195,0 c -0.2754091,0.612021 -0.4199219,1.244178 -0.4199219,1.878906 0,0.586308 0.1172738,1.166119 0.34375,1.722657 2.469e-4,6.06e-4 -2.472e-4,0.0013 0,0.002 0.4616675,1.174144 1.1678027,2.049935 2.1289062,2.474609 a 0.65860366,0.65860366 0 0 0 0.00781,0.0039 c 0.8286494,0.352413 1.5586814,0.548829 2.2304684,0.548829 0.586313,0 1.170378,-0.116216 1.740235,-0.339844 1.181788,-0.458451 2.082653,-1.322653 2.601562,-2.488282 0.330502,-0.705376 0.488282,-1.498294 0.488282,-2.353515 0,-0.214294 -0.0234,-0.559044 -0.06836,-1.134766 -0.04332,-0.676666 -0.248075,-1.447023 -0.591797,-2.357422 a 0.65860366,0.65860366 0 0 0 -0.0039,-0.01367 c -0.215809,-0.535206 -0.423732,-1.120249 -0.625,-1.75 -0.190291,-0.60397 -0.279297,-1.133312 -0.279297,-1.585938 0,-1.026584 0.278067,-1.7499346 0.820313,-2.3066406 a 0.65860366,0.65860366 0 0 0 0.002,-0.00195 c 0.542177,-0.5638645 1.235121,-0.8457031 2.236328,-0.8457031 1.04226,0 1.792542,0.302684 2.402344,0.9199219 a 0.65860366,0.65860366 0 0 0 0.0039,0.00195 c 0.606572,0.606572 0.90625,1.3689279 0.90625,2.4335939 0,1.572702 -0.589605,3.408904 -1.837891,5.498047 a 0.65860366,0.65860366 0 0 0 -0.002,0 c -1.320121,2.215588 -2.011719,4.290309 -2.011719,6.228515 0,1.135656 0.404802,2.137499 1.199219,2.810547 a 0.65860366,0.65860366 0 0 0 0.0039,0.0039 c 0.75835,0.631956 1.698343,0.957031 2.716797,0.957031 1.227821,0 2.438439,-0.64332 3.644531,-1.773438 a 0.65860366,0.65860366 0 0 0 0.03711,-0.921875 L 24.611328,23.130859 A 0.65860366,0.65860366 0 0 0 23.6875,23.078125 c -0.83238,0.732494 -1.487863,1.012762 -1.851562,1.015625 -0.490025,-0.0128 -0.768941,-0.128804 -0.923829,-0.271484 -0.154694,-0.142502 -0.25969,-0.35908 -0.27539,-0.78711 0.0033,-1.431752 0.595963,-3.259206 1.855469,-5.439453 1.332579,-2.306741 2.033203,-4.364066 2.033203,-6.207031 -10e-7,-1.7094646 -0.553007,-3.1902892 -1.650391,-4.2988282 -1.096122,-1.1162349 -2.559684,-1.6875 -4.240234,-1.6875 z M 12.125,16.433594 c 0.207579,0 0.558685,0.07879 1.007812,0.279297 a 0.65860366,0.65860366 0 0 0 0.0039,0.002 c 0.325823,0.142905 0.588789,0.418207 0.804687,0.976562 a 0.65860366,0.65860366 0 0 0 0.002,0.0059 c 0.09694,0.242349 0.140625,0.469511 0.140625,0.695312 0,0.206742 -0.07961,0.56478 -0.279296,1.021484 -1.7e-4,3.8e-4 -0.0018,-3.79e-4 -0.002,0 -0.141144,0.315308 -0.416373,0.578316 -0.976562,0.794922 -0.255126,0.09921 -0.487088,0.142578 -0.712891,0.142578 -0.211018,0 -0.561402,-0.07771 -1.003906,-0.265624 -0.303312,-0.138564 -0.572345,-0.422337 -0.798828,-0.996094 -0.09779,-0.252742 -0.142578,-0.486321 -0.142578,-0.710938 0,-0.21264 0.07548,-0.556983 0.265625,-0.99414 9.3e-5,-2.15e-4 0.0019,2.15e-4 0.002,0 0.141518,-0.316151 0.419067,-0.583253 0.982422,-0.808594 0.243294,-0.09732 0.47252,-0.142578 0.707031,-0.142578 z" />
    </g>
    <g transform="scale(0.805326,1.2417332)">
      <path d="m 29.052173,23.815766 0.951868,0 q 1.903736,0 2.474857,-0.584719 0.584719,-0.584719 0.584719,-2.529249 l 0,-3.372332 q 0,-2.121306 0.611915,-3.086772 0.611915,-0.965466 2.121306,-1.332615 -1.509391,-0.339953 -2.121306,-1.305419 -0.611915,-0.965466 -0.611915,-3.1003697 l 0,-3.3723321 q 0,-1.9309321 -0.584719,-2.515651 -0.571121,-0.598317 -2.474857,-0.598317 l -0.951868,0 0,-1.9445302 0.856682,0 q 3.38593,0 4.514573,1.0062604 1.142242,0.9926623 1.142242,3.9978453 l 0,3.2635472 q 0,2.0261191 0.734298,2.8148091 0.734298,0.775093 2.66523,0.775093 l 0.843083,0 0,1.94453 -0.843083,0 q -1.930932,0 -2.66523,0.788691 -0.734298,0.78869 -0.734298,2.842005 l 0,3.249949 q 0,3.005183 -1.142242,4.011444 -1.128643,1.00626 -4.514573,1.00626 l -0.856682,0 0,-1.958128 z" />
    </g>
    <g transform="scale(0.80532598,1.2417332)">
      <path d="m 10.700812,23.861077 0,1.958128 -0.8430829,0 q -3.3859302,0 -4.5417698,-1.00626 -1.1422415,-1.006261 -1.1422415,-4.011444 l 0,-3.249949 q 0,-2.053315 -0.7342981,-2.842005 -0.7342982,-0.788691 -2.66523025,-0.788691 l -0.82948492,0 0,-1.94453 0.82948492,0 q 1.94453025,0 2.66523025,-0.775093 0.7342981,-0.78869 0.7342981,-2.8148091 l 0,-3.2635472 q 0,-3.0051831 1.1422415,-3.9978453 1.1558396,-1.00626042 4.5417698,-1.00626042 l 0.8430829,0 0,1.94453022 -0.9246715,0 q -1.917334,0 -2.5020529,0.598317 -0.5847189,0.598317 -0.5847189,2.5156509 l 0,3.3723321 q 0,2.1349038 -0.6255132,3.1003698 -0.6119151,0.965466 -2.1077075,1.305419 1.5093905,0.367149 2.1213056,1.332615 0.6119151,0.965466 0.6119151,3.086772 l 0,3.372332 q 0,1.917334 0.5847189,2.515651 0.5847189,0.598317 2.5020529,0.598317 l 0.9246715,0 z" />
    </g>
  </g>
</svg>

    
    </b>
    <b id="jsdocpPkgName">templeo</b>
    <b>|</b>
    <hr/>
  </a>
  <a href="https://www.npmjs.com/package/templeo" id="jsdocpModule"
    title="npm"
    class="jsdocp-icon ">
    
    <svg version="1.1" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
      <g class="jsdocp-icon-svg-el pkg-icons" stroke="none" transform="translate(0,24) scale(0.1,-0.1)">
        <path d="M 0,120 0,0 l 120,0 120,0 0,120 0,120 -120,0 -120,0 z m 200,0 c 0,-73 0.23256,-80 0.23256,-80 0,0 -27.97435,0.741211 -40.61273,0.707427 C 159.61983,67.551504 160,70.949947 160,100 c 0,53 -2,60 -20,60 -18,0 -20,-7 -20,-60 l 0,-60 -40,0 -40,0 0,80 0,80 80,0 80,0 z"/>
      </g>
    </svg>
    
  </a>
  <a href="CHANGELOG.html" id="jsdocpChangelog" data-jsdocp-root-href="https://github.com/ugate/templeo/CHANGELOG.html"
    title="Changelog"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 64 64" height="64" width="64" xmlns="http://www.w3.org/2000/svg">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="M 29.896194,0.97873581 C 13.435048,0.97873581 1.1072664e-7,15.139296 0,32.489368 0,49.839439 13.435048,64 29.896194,64 46.357339,64 59.792385,49.839438 59.792388,32.489368 a 4.2273908,4.4556761 0 1 0 -8.453721,0 c -10e-7,12.534501 -9.550175,22.600399 -21.442473,22.600399 -11.892299,0 -21.4424739,-10.065899 -21.4424739,-22.600399 0,-12.5345 9.5501749,-22.6003988 21.4424739,-22.6003988 a 4.2273908,4.4556761 0 1 0 0,-8.91023339 z" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 55.529412,24.680907 -8.470588,10.142582 16.941176,0 z"/>
      <rect class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        transform="matrix(0.6882785,0.72544656,-0.6882785,0.72544656,0,0)" y="-38.592953" x="38.592953" height="39.814472" width="11.375563" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 23.705056,39.295314 8.338477,-1.11407 -7.281487,-7.674698 z"/>
    </svg>
    
  </a>
  <a href="https://github.com/ugate/templeo#readme" id="jsdocpSourceCode"
    title="Source Code"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 10 16" width="24" height="24" xmlns="http://www.w3.org/2000/svg" id="jsdocpSourceIcon">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="evenodd"
        d="M8 1a1.993 1.993 0 0 0-1 3.72V6L5 8 3 6V4.72A1.993 1.993 0 0 0 2 1a1.993 1.993 0 0 0-1 3.72V6.5l3 3v1.78A1.993 1.993 0 0 0 5 15a1.993 1.993 0 0 0 1-3.72V9.5l3-3V4.72A1.993 1.993 0 0 0 8 1zM2 4.2C1.34 4.2.8 3.65.8 3c0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm3 10c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm3-10c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2z"></path>
    </svg>
    <!-- GitHub icon -->
    <svg version="1.1" viewBox="0 0 16 16" height="24" width="24" xmlns="http://www.w3.org/2000/svg" class="jsdocp-remove-me" id="jsdocpGithubIcon">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none"  fill-rule="evenodd"
        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
    </svg>
    
  </a>
  <!-- versions.json should point to the latest list -->
  <a id="jsdocpVersionsIcon"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 64 64" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 63.999999,25.315556 -24.108295,0 9.74288,-10.026667 C 39.927261,5.6888885 24.210644,5.3333335 14.503322,14.933333 c -9.7073234,9.635555 -9.7073234,25.173334 0,34.808888 9.707322,9.635556 25.423939,9.635556 35.131262,0 4.835883,-4.764443 7.253823,-10.346666 7.253823,-17.386666 l 7.111592,0 c 0,7.039999 -3.1291,16.177777 -9.387301,22.364444 -12.480844,12.373334 -32.748879,12.373334 -45.2297224,0 -12.445286,-12.337778 -12.55196,-32.39111 -0.071116,-44.7288881 12.4808434,-12.3377774 32.4999734,-12.3377774 44.9808174,0 L 64,-5e-7 64,25.315556 Z" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 33.775734,17.777777 0,15.111111 12.445286,7.395556 -2.560173,4.302222 -15.218806,-9.031112 0,-17.777777 5.333693,0 z" />
    </svg>
    
  </a>
  <select id="jsdocpVersions"
    title="v1.0.0"
    data-jsdocp-version-base="/templeo"
    data-jsdocp-json-url="/templeo/versions.json"
    data-jsdocp-type=""
    data-jsdocp-from="1.0.0"
    data-jsdocp-version="1.0.0">
  </select>
</div>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Tutorials</li><li class="nav-item"><a href="tutorial-1-basics.html">The Basics</a></li><li class="nav-item"><a href="tutorial-2-cache.html">Cache</a></li><li class="nav-item"><a href="tutorial-3-examples.html">Examples</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Cachier.html">Cachier</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#.contentURL">contentURL</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#.waiter">waiter</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#clear">clear</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#compile">compile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#getRegistered">getRegistered</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#modules">modules</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#read">read</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#readWriteName">readWriteName</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#register">register</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#registerHelper">registerHelper</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#registerPartial">registerPartial</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#unregister">unregister</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#write">write</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="CachierDB.html">CachierDB</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierDB.html#clear">clear</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierDB.html#compile">compile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierDB.html#read">read</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierDB.html#register">register</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierDB.html#write">write</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="CachierFiles.html">CachierFiles</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierFiles.html#clear">clear</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierFiles.html#compile">compile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierFiles.html#read">read</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierFiles.html#register">register</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierFiles.html#write">write</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-templeo_options-TemplateOpts.html">TemplateOpts</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo_options-TemplateOpts.html#.defaultOptionMerge">defaultOptionMerge</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo_options-TemplateOpts.html#build">build</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-templeo-Engine.html">Engine</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#.create">create</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#clearCache">clearCache</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#compile">compile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#getRegistered">getRegistered</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#register">register</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#registerHelper">registerHelper</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#registerPartial">registerPartial</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#renderPartial">renderPartial</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#renderPartialGenerate">renderPartialGenerate</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#unregister">unregister</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Sandbox.html">Sandbox</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sandbox.html#.compile">compile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sandbox.html#.deserialzeBlock">deserialzeBlock</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sandbox.html#.deserialzeFunction">deserialzeFunction</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sandbox.html#.guid">guid</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sandbox.html#.serialzeFunction">serialzeFunction</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="TemplateDBOpts.html">TemplateDBOpts</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="TemplateFileOpts.html">TemplateFileOpts</a></span></li><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-templeo.html">templeo</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-templeo_options.html">templeo/options</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">lib/cachier-db.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const TemplateDBOpts = require('./template-db-options');
const Cachier = require('./cachier');
const Sandbox = require('./sandbox');
// TODO : ESM uncomment the following lines...
// TODO : import * as TemplateDBOpts from './template-db-options.mjs';
// TODO : import * as Cachier from './cachier.mjs';
// TODO : import * as Sandbox from './sandbox.mjs';

/**
 * Persistence cache manager that uses an [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) or
 * [LevelDB](https://www.npmjs.com/package/level) store for partial content and compilation segments. The type of DB used
 * is first determined by the presence of an `indexedDB` on the _global/window_ reference that contains either an
 * [IDBFactory](https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory) or other supported IndexedDB-like interface
 * (e.g. `LevelUP`). When an `indexedDB` reference is not present, an atempt to load a __module__ using the
 * `options.dbTypeName` as the module name/path that resolves into a function that takes a location path from
 * `options.dbLocName` as it's first argument.
 */
class CachierDB extends Cachier {
// TODO : ESM use... export class CachierDB extends Cachier {

  /**
   * Constructor
   * @param {TemplateDBOpts} [opts] The {@link TemplateDBOpts}
   * @param {Function} [readFormatter] The `function(string, readFormatOptions)` that will return a formatted string for __reading__
   * data using the `options.readFormatOptions` from {@link TemplateOpts} as the formatting options. Typically reads are for __HTML__
   * _minification_ and/or _beautifying_. __NOTE: Use with caution as syntax errors may result depending on the formatter used and the
   * complexity of the data being formatted!__ 
   * @param {Function} [writeFormatter] The `function(string, writeFormatOptions)` that will return a formatted string for __writting__
   * data using the `options.writeFormatOptions` from {@link TemplateOpts} as the formatting options. Typically reads are for __JS__
   * _minification_ and/or _beautifying_. __NOTE: Use with caution as syntax errors may result depending on the formatter used and the
   * complexity of the data being formatted!__ 
   * @param {Object} [log] The log for handling logging output
   * @param {Function} [log.debug] A function that will accept __debug__ level logging messages (i.e. `debug('some message to log')`)
   * @param {Function} [log.info] A function that will accept __info__ level logging messages (i.e. `info('some message to log')`)
   * @param {Function} [log.warn] A function that will accept __warning__ level logging messages (i.e. `warn('some message to log')`)
   * @param {Function} [log.error] A function that will accept __error__ level logging messages (i.e. `error('some message to log')`)
   */
  constructor(opts, readFormatter, writeFormatter, log) {
    super(opts instanceof TemplateDBOpts ? opts : new TemplateDBOpts(opts), readFormatter, writeFormatter, log);
  }

  /**
   * @override
   * @inheritdoc
   */
  async register(data, read, write) {
    const ns = internal(this), opts = ns.this.options, log = ns.this.log;
    var rtn;
    const storage = read || write ? { db: ns.at.db } : null;
    try {
      if (read) {
        // read all keys in store and register any template, partials and/or context found
        let proms;
        await execDB(null, opts, null, storage, ns.this.readFormatter, true, log, true, undefined, async function recordDB(storage, storeName, key, params, json) {
          if (!json &amp;&amp; typeof json === 'undefined') {
            if (!proms) proms = [ns.this.unregister(key)];
            else proms.push(ns.this.unregister(key));
          } else if (storeName === 'data')  {
            const jsonType = json &amp;&amp; typeof json;
            await ns.this.registerPartial(key, jsonType === 'object' &amp;&amp; json.hasOwnProperty('content') ? json.content : params, json.extension);
            //if (json &amp;&amp; data &amp;&amp; !data.hasOwnProperty(key)) data[key] = JSON.parse(JSON.stringify(json));
          }
        }, function openDB(store) {
          storage.db = store.db;
        });
        if (proms) await Cachier.waiter(proms, 'Failed to unregister one or more template contents', false);
      }
      rtn = await super.register(data, read, write); // calls this.write as-needed
      storage.db = storage.db || ns.at.db;
    } finally {
      if (read || write) await closeDB(storage, opts, log, true);
    }
    return rtn;
  }

  /**
   * @override
   * @inheritdoc
   */
  async compile(name, template, extension) {
    const ns = internal(this), log = ns.this.log;
    var fn;
    try {
      fn = await super.compile(name, template, extension);
    } finally {
      const storage = { db: ns.at.db };
      await closeDB(storage, ns.this.options, log, true);
    }
    return fn;
  }

  /**
   * @override
   * @inheritdoc
   */
  async read(name, forContent, extension, params) {
    if (!name) throw new Error(`Missing "name" for value "${name}" on pre-compile read from DB`);
    const ns = internal(this), opts = ns.this.options, store = ns.at, log = ns.this.log, formatter = ns.this.readFormatter;
    const path = await ns.this.readWriteName(name, opts, params, store, forContent, extension);
    return dbReader(name, path, extension, forContent, opts, params,store, formatter, false, log, true);
  }

  /**
   * @override
   * @inheritdoc
   */
  async write(name, data, forContent, extension, params) {
    const ns = internal(this), opts = ns.this.options, store = ns.at, log = ns.this.log, formatter = ns.this.writeFormatter;
    const path = await ns.this.readWriteName(name, opts, params, store, forContent, extension);
    return dbWriter(name, path, extension, forContent, opts, params, store, data, formatter, false, log, true);
  }

  /**
   * Clears templates that may reside in-memory, __optionally__ clears the IndexedDB keys in the cache store(s) and
   * __closes__ any lingering DB connections.
   * @override
   * @param {Boolean} [all=true] When `true` all of the keys in the IndexedDB cache store(s) will be __removed__
   */
  async clear(all = true) {
    await super.clear(all);
    const ns = internal(this), opts = ns.this.options, log = ns.this.log, storage = { db: ns.at.db };
    // remove all keys from the DB
    if (all &amp;&amp; log.info) log.info(`DB: Clearing all stored keys...`);
    let proms;
    await execDB(null, opts, null, storage, null, true, log, true, true, function recordDB(store, storeName, key, params, json) {
      if (!proms) proms = [ns.this.unregister(key)];
      else proms.push(ns.this.unregister(key));
    }, function openDB(store) {
      storage.db = store.db;
    }, true);
    if (all) delete ns.at.db;
    if (proms) await Cachier.waiter(proms, 'Failed to unregister one or more template contents while clearing cache', false);
  }

  /**
   * @override
   * @inheritdoc
   */
  get operations() {
    const ops = super.operations;
    const op = Object.freeze({
      read: dbReader,
      write: dbWriter,
      finish: dbFinish,
      scopes: Object.freeze([
        execDB,
        closeDB
      ])
    });
    if (Array.isArray(ops)) ops.splice(0, 0, op);
    else return [op, ops];
    return ops;
  }
}

// TODO : ESM remove the following lines...
module.exports = CachierDB;

/**
 * File reader that reads the contents of a file during compile-time or render-time
 * @private
 * @ignore
 * @param {String} name The name of template that will be read
 * @param {String} path The path to the template that will be read
 * @param {String} ext The path extension
 * @param {Boolean} forContent The flag indicating that the read is for content. Otherwise, the read is for rendering functions.
 * @param {(TemplateDBOpts | Function)} optional Either the options or a `function(name:String):*` that returns an
 * option value by name
 * @param {URLSearchParams} [params] The search parameters to use for the read 
 * @param {Object} store The JSON storage space
 * @param {Function} [readFormatter] The formatting function to use to format the read content
 * @param {Boolean} [close] When `true`, the resources will be closed after execution is complete
 * @param {Object} [log] The log that can contain functions for each of the following: `error`/`warn`/`info`/`debug`
 * @param {Boolean} [isCompile] `true` when execution is for compilation, _falsy_ when rendering
 * @param {Function} [recordfunc] A `function(store:Object, storeName:String, key:String[, params:(URLSearchParams | Object), json:Object])`
 * that will be called for each action taken on a record.
 * @param {Function} [openFunc] A `function(store:Object)` that will be called when the DB is opened.
 * @returns {(String | undefined)} The read file template content or `undefined` when reading all partial content
 */
async function dbReader(name, path, ext, forContent, optional, params, store, readFormatter, close, log, isCompile, recordFunc, openFunc) {
  let rtn;
  if (log.info &amp;&amp; name) {
    log.info(`DB: 📖 Reading template "${forContent ? 'data' : 'sources'}" for "${name}" @ "${path}" (${isCompile ? 'compile' : 'render'}-time)`);
  }
  try {
    rtn = await execDB(path, optional, params, store, readFormatter, close, log, isCompile, undefined, recordFunc, openFunc);
  } catch (err) {
    try {
      await closeDB(store, optional, log, isCompile);
    } catch (errc) {}
    throw err;
  }
  return rtn;
}

/**
 * File writer that writes the contents of a file during compile-time or render-time
 * @private
 * @ignore
 * @param {String} name The name of template that will be write
 * @param {String} path The path to the template that will be write
 * @param {String} ext The path extension
 * @param {Boolean} forContent The flag indicating that the write is for content. Otherwise, the write is for rendering functions.
 * @param {(TemplateDBOpts | Function)} optional Either the options or a `function(name:String):*` that returns an
 * option value by name
 * @param {URLSearchParams} [params] The search parameters to use for the write 
 * @param {Object} store The JSON storage space
 * @param {*} data The value that will be stored (cannot be `undefined`)
 * @param {Function} [writeFormatter] The formatting function to use to format the write content
 * @param {Boolean} [close] When `true`, the resources will be closed after execution is complete
 * @param {Object} [log] The log that can contain functions for each of the following: `error`/`warn`/`info`/`debug`
 * @param {Boolean} [isCompile] `true` when execution is for compilation, _falsy_ when rendering
 * @param {Function} [recordfunc] A `function(store:Object, storeName:String, key:String[, params:(URLSearchParams | Object), json:Object])`
 * that will be called for each action taken on a record.
 * @param {Function} [openFunc] A `function(store:Object)` that will be called when the DB is opened.
 * @returns {(String | undefined)} The written file template content or `undefined` when writting all partial content
 */
async function dbWriter(name, path, ext, forContent, optional, params, store, data, writeFormatter, close, log, isCompile, recordFunc, openFunc) {
  let rtn;
  if (typeof data === 'undefined') return rtn;
  const isOptionFunc = typeof optional === 'function', useCache = isOptionFunc ? optional('cacheRawTemplates') : optional.cacheRawTemplates;
  if (!useCache) return;
  if (!name) throw new Error(`Missing "name" for value "${name}" on write to DB`);
  if (!path) throw new Error(`Missing "path" for value "${path}" on write to DB`);
  if (log.info) {
    log.info(`DB: ✏️ Writting template "${forContent ? 'data' : 'sources'}" for "${name}" @ "${path}" (${isCompile ? 'compile' : 'render'}-time)`);
  }
  const dataType = typeof data, dataIsObj = dataType === 'object', put = { name: path, shortName: dataIsObj &amp;&amp; ext !== 'json' ? data.name : name };
  if (forContent) {
    put.content = dataIsObj &amp;&amp; ext !== 'json' ? data.content : data;
    put.extension = ext;
  } else if (dataIsObj) put.func = data.func;
  else put.func = data;
  if (!forContent) {
    if (typeof put.func === 'function') {
      if (!put.func.name) throw new Error('Rendering function must be named, but found anonymous');
      put.func = put.func.toString();
    } else if (typeof put.func === 'string') {
      try { // validate string is in fact a valid function
        put.func = (new Function(`return ${put.func}`))();
        if (typeof put.func !== 'function') throw new Error('Invalid function string');
        if (!put.func.name) throw new Error('String must contain a named function, but found anonymous');
        put.func = put.func.toString();
      } catch (err) {
        err.message += ` &lt;- Unable to validate rendering function string for DB storage: ${put.func}`;
        throw err;
      }
    } else throw new Error('Invalid template rendering function passed to IndexedDB write operation. It must contain'
      + ` a valid function or deserialized function string rather than the supplied "${put.func}"`);
  }
  try {
    rtn = await execDB(path, optional, params, store, writeFormatter, close, log, isCompile, put, recordFunc, openFunc);
  } catch (err) {
    try {
      await closeDB(store, optional, log, isCompile);
    } catch (errc) {}
    throw err;
  }
  return rtn;
}

/**
 * Releases any DB resources that have been used after finishing DB operations
 * @private
 * @ignore
 * @param {Object} store The JSON storage space
 * @param {(TemplateDBOpts | Function)} optional Either the options or a `function(name:String):*` that returns an
 * option value by name
 * @param {Object} [log] The log that can contain functions for each of the following: `error`/`warn`/`info`/`debug`
 */
async function dbFinish(store, optional, log) {
  const isOptionFunc = typeof optional === 'function', policy = isOptionFunc ? optional('renderTimePolicy') : optional.renderTimePolicy;
  if (policy === 'read-write-and-close') return;
  if (log.info) log.info('DB: ❌ Releasing resources for DB (render-time)');
  return closeDB(store, optional, log);
}

/**
 * When `name` is present, a single record that will be captured or deleted. Otherwise, captures or removes every DB key that
 * currently resides in the DB. Each key found will be set as `storage.data[key]` or `storage.sources[key]`. When keys are
 * being removed, they are also removed from the provided `storage`. The type of DB used is first determined by the presence of
 * an `indexedDB` on the _global/window_ reference that contains either an
 * [IDBFactory](https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory) or other supported IndexedDB-like interface (e.g.
 * `LevelUP`). When an `indexedDB` reference is not present, an atempt to load a __module__ using the `options.dbTypeName` as
 * the module name/path that resolves into a function that takes a location path from `options.dbLocName` as it's first
 * argument. At that point the underlying
 * [IndexedDB is opened](https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory/open) (or
 * [LevelDB is opened](https://github.com/Level/level#dbopencallback)). However, it's important to note that __the DB is never__
 * __closed and should be handled accordingly__.
 * @private
 * @ignore
 * @param {String} [name] The name of the single record that will be captured or deleted. Omit to capture or remove all
 * keys in the DB store.
 * @param {(TemplateDBOpts | Function)} optional Either the options or a `function(name:String):*` that returns an
 * option value by name.
 * @param {(URLSearchParams | String)} [params] The URL parameters to use (JSON or URL encoded).
 * @param {Object} storage The object where the `db` (and `idb` for IndexedDB), `data` and `sources` are stored.
 * @param {Function} [formatter] The function that will format written sources during include discovery (if any). The formatting function
 * takes 1 or 2 arguments with the first being the content that will be formatted and the second being
 * @param {Boolean} [close] When `true`, the DB connection will be closed after execution is complete.
 * @param {Object} [log] The log that can contain functions for each of the following: `error`/`warn`/`info`/`debug`.
 * @param {Boolean} [isCompile] `true` when execution is for compilation, _falsy_ when rendering
 * @param {(String | Boolean)} [valueOrRemove] `true` when removing keys, `undefined` when capturing keys or any other value
 * when setting a key (using `name` as the key).
 * @param {Function} [recordfunc] A `function(store:Object, storeName:String, key:String[, params:(URLSearchParams | Object), json:Object])`
 * that will be called for each action taken on a record.
 * @param {Function} [openFunc] A `function(store:Object)` that will be called when the DB is opened.
 * @param {Boolean} [openOnly] A flag that indicates that the DB will be opened, but will not process any data
 * @returns {Object} The passed `storage` object.
 */
async function execDB(name, optional, params, storage, formatter, close, log, isCompile, valueOrRemove, recordfunc, openFunc, openOnly) {
  const isOptionFunc = typeof optional === 'function';
  const policy = isOptionFunc ? optional('renderTimePolicy') : optional.renderTimePolicy;
  if (!name) { // init all key read?
    const noInit = !policy.includes('read-all-on-init-when-empty'), sdata = !noInit &amp;&amp; storage.data ? Object.getOwnPropertyNames(storage.data) : null;
    let sdcnt = 0;
    if (sdata &amp;&amp; sdata.length) { // exclude the default template from the count for determining emptiness
      const dnm = isOptionFunc ? optional('defaultTemplateName') : optional.defaultTemplateName, rx = /\.([0-9a-z]+)(?:[\?#]|$)/i;
      sdcnt = sdata.reduce((a, cnm) => (cnm &amp;&amp; cnm.name || cnm).replace(rx, '') !== dnm ? a + 1 : a, 0);
    }
    if (noInit || sdcnt) {
      if (log &amp;&amp; log.info) {
        log.info(`DB: ${valueOrRemove === true ? '❌ Remove' : valueOrRemove ? '✔️ Put' : '📖 Capture' } for all keys will be skipped for policy`
          + ` "${policy}"${sdcnt ? ` on ${sdcnt} non-empty records` : ''} (${isCompile ? 'compile' : 'render'}-time)`);
      }
      return;
    }
  }
  const dbTypeName = isOptionFunc ? optional('dbTypeName') : optional.dbTypeName;
  const dbLocName = isOptionFunc ? optional('dbLocName') : optional.dbLocName;
  const encoding = isOptionFunc ? optional('encoding') : optional.encoding;
  const dbDStore = 'data';
  const dbSStore = 'sources';
  const storeNames = [dbDStore, dbSStore];
  storage[dbDStore] = storage[dbDStore] || {};
  storage[dbSStore] = storage[dbSStore] || {};
  return new Promise(async (resolve, reject) => {
    const end = async error => {
      if (close) {
        const db = storage.db &amp;&amp; (storage.db.idb || storage.db.dbs);
        if (db &amp;&amp; typeof db.close === 'function') {
          try {
            await closeDB(storage, optional, log, isCompile);
          } catch (err) {
            if (log &amp;&amp; log.error) log.error(`DB: ⚠️ Failed to close connection (${isCompile ? 'compile' : 'render'}-time)`);
            return reject(err);
          }
        } else if (log &amp;&amp; log.info) {
          log.info(`DB: 🔌 Connection may already be closed or manual "close" functionality is not implemented (${isCompile ? 'compile' : 'render'}-time)`);
        }
      }
      if (error) reject(error);
      else resolve(storage);
    };
    if (!storage.db) {
      storage.db = {
        toJSON: () => '', // prevent serialization via JSON.stringify
        dbs: dbTypeName === 'indexedDB' ? this &amp;&amp; this[dbTypeName] :
          new Promise(async (resolveModule, rejectModule) => {
            if (log &amp;&amp; log.info) {
              log.info(`DB: 🎬 Loading module "${dbTypeName}" passing location "${dbLocName}"${name ? ` while processing "${name}"` : ''}`
              + ` using policy "${policy}" (${isCompile ? 'compile' : 'render'}-time)`);
            }
            try {
              const initFunc = (typeof require !== 'undefined' ? require(dbTypeName) : /*TODO : ESM use... await import(dbTypeName)*/null);
              const db = initFunc(dbLocName, (err, db) => {
                if (err) {
                  const nerr = new err.constructor();
                  nerr.stack = `Failed to initialize module "${dbTypeName}" passing location "${dbLocName}"${name ? ` while processing "${name}"` : ''}`
                  + ` using policy "${policy}" (${isCompile ? 'compile' : 'render'}-time)\n${err.stack}`;
                  rejectModule(nerr);
                } else resolveModule(db);
              });
              if (db instanceof Promise) resolveModule(await db);
            } catch (err) {
              const nerr = new err.constructor();
              nerr.stack = `Failed to load module "${dbTypeName}" with location "${dbLocName}"${name ? ` while processing "${name}"` : ''}`
              + ` using policy "${policy}" (${isCompile ? 'compile' : 'render'}-time)\n${err.stack}`;
              rejectModule(nerr);
            }
          })
      };
      if (!storage.db.dbs) {
        return end(new Error(`Unable to load "${dbTypeName}" ${dbTypeName === 'indexedDB' ? 'from global/window scope' :
          ` module "${dbTypeName}" passing location "${dbLocName}"`}`));
      }
      if (storage.db.dbs instanceof Promise) {
        try {
          storage.db.dbs = await storage.db.dbs;
        } catch (err) {
          return end(err);
        }
      }
      if (typeof openFunc === 'function') openFunc(storage);
    }
    const idbName = storage.db &amp;&amp; storage.db.dbs &amp;&amp; storage.db.dbs.constructor &amp;&amp; storage.db.dbs.constructor.name, isIndexedDB = idbName === 'IDBFactory';
    const valType = valueOrRemove === null ? 'undefined' : typeof valueOrRemove, remove = valType === 'boolean' &amp;&amp; valueOrRemove ? true : false;
    const hasRecordfunc = typeof recordfunc === 'function';
    if (log &amp;&amp; log.debug) log.debug(`DB: 🆔 Using "${idbName}" from "${dbTypeName}"`);
    if (isIndexedDB) {
      if (!storage.db.idb) { // set idb to IDBDatabase instance
        storage.db.idb = await new Promise((resolve, reject) => {
          const req = storage.db.dbs.open(dbLocName); // IDBOpenDBRequest
          req.onerror = event => reject(event.error);
          req.onupgradeneeded = event => {
            event.target.createObjectStore(dbDStore, { autoIncrement: true });
            event.target.createObjectStore(dbSStore, { autoIncrement: true });
          };
          req.onsuccess = event => resolve(event.target.result ? undefined : null);
        });
        if (log &amp;&amp; log.info) log.info(`DB: 🆔 Using "${idbName}" from "${dbTypeName}"`);
        if (typeof openFunc === 'function') openFunc(storage);
        if (openOnly) return end();
      }
      if (name) { // single record processing
        let tx, store, req, reqCnt = 0, error, storeCount = storeNames.length;
        for (let storeName of storeNames) {
          if (valType !== 'undefined') { // put
            let hasContent = valueOrRemove.hasOwnProperty('content');
            if ((hasContent &amp;&amp; storeName !== dbDStore) || (!hasContent &amp;&amp; storeName !== dbSStore)) {
              storeCount--; // put should only go to one store
              continue;
            }
          }
          tx = storage.idb.transaction([storeName], 'readwrite');
          store = tx.objectStore(storeName);
          req = remove ? store.delete(name) : valType !== 'undefined' ? store.put(valueOrRemove, name) : store.get(name);
          req.onerror = event => {
            reqCnt++;
            if (error) return; // already had error
            error = event.error;
            error.message += ` &lt;- Failed to "${remove ? 'delete' : valType !== 'undefined' ? 'put' : 'get'}" for IndexedDB key "${name}"`;
            if (log &amp;&amp; log.error) log.error(error);
            return end(error);
          };
          req.onsuccess = () => {
            reqCnt++;
            let val;
            if (remove) {
              delete storage[dbDStore][name];
              delete storage[dbSStore][name];
              if (hasRecordfunc) {
                recordfunc(storage, dbDStore, name, params);
                recordfunc(storage, dbSStore, name, params);
              }
            } else {
              val = req.hasOwnProperty('result') ? req.result : valueOrRemove;
              if (val) {
                const hasContent = val.hasOwnProperty('content'), valStoreName = hasContent ? dbDStore : dbSStore;
                storage[valStoreName][name] = val;
                if (typeof storage[valStoreName][name].func === 'string') {
                  try {
                    storage[valStoreName][name].func = (new Function(`return ${storage[valStoreName][name].func}`))();
                  } catch (errf) {
                    error = errf;
                    error.message += ` while deserializing function "${storage[valStoreName][name].func.name}"`
                    + ` &lt;- Failed to "${remove ? 'delete' : valType !== 'undefined' ? 'put' : 'get'}" for IndexedDB key "${name}"`;
                    if (log &amp;&amp; log.error) log.error(error);
                    return end(error);
                  }
                }
                if (hasRecordfunc) recordfunc(storage, valStoreName, name, params, val);
              }
            }
            if (log &amp;&amp; (log.info || log.debug)) {
              (log.debug || log.info)(`DB: Completed "${remove ? '❌ delete' : valType !== 'undefined' ? '✔️ put' : '📖 get'}"`
                + ` for IndexedDB key "${name}" (${isCompile ? 'compile' : 'render'}-time)${log.debug &amp;&amp; !remove ? ` with: ${JSON.stringify(val)}` : ''}`);
            }
            if (!error &amp;&amp; reqCnt >= storeCount) end();
          };
          return;
        }
      } else if (log &amp;&amp; log.info) log.info(`DB: ${remove ? '❌ Removing' : '📖 Getting'} all IndexedDB keys from ${storeNames.join()}`);
      // multi-record processing
      const errors = [], dels = remove ? [] : null;
      var cnt = 0, done;
      const errd = (err, cacheName, msg) => {
        err.message = `${err.message || ''} - ${remove ? 'Removal' : 'Capture'} of template on "${cacheName}" failed for IndexedDB ${msg || ''}`;
        err.cache = cacheName;
        errors.push(err);
        if (log &amp;&amp; log.error) {
          log.error(err);
        }
      };
      const promd = async () => {
        if (!done &amp;&amp; ++cnt &lt; storeNames.length) return;
        done = true;
        if (remove &amp;&amp; dels) {
          for (let del of dels) {
            try {
              await del.promise;
              delete storage[del.cacheName][del.key];
              if (hasRecordfunc) recordfunc(storage, del.cacheName, del.key, params);
              if (log &amp;&amp; log.info) {
                log.info(`DB: Completed "❌ delete" on "${del.cacheName}" for IndexedDB key "${del.key}" (${isCompile ? 'compile' : 'render'}-time)`);
              }
            } catch (err) {
              errd(err, del.cacheName, `Failed to "delete" on "${del.cacheName}" for IndexedDB key "${del.key}"`);
            }
          }
        }
        var errCnt = errors.length;
        if (errCnt) {
          var error;
          if (errCnt === 1) error = errors[0];
          else {
            error = new Error(`${errCnt} errors occurred during IndexedDB ${remove ? 'removal' : 'capture'}`
              + '(see "error.errors" and "error.reads" for more details)');
            error.errors = errors;
          }
          error.reads = { [dbDStore]: storage[dbDStore], [dbSStore]: storage[dbSStore] };
          return end(error);
        } else await end();
      };
      for (let storeName of storeNames) {
        const tx = storage.idb.transaction([storeName]), store = tx.objectStore(storeName), req = store.openCursor();
        tx.onerror = (cacheName => event => {
          errd(event.error, cacheName);
          promd();
        })(storeName);
        tx.oncomplete = () => promd();
        req.onerror = (cacheName => event => {
          errd(event.error, cacheName);
        })(storeName);
        req.onsuccess = (cacheName => event => {
          const cursor = event.target.result;
          if (!cursor) return errors.push(new Error(`Failed to "${remove ? 'delete' : 'get'}" on "${cacheName}" for IndexedDB`
            + ' request due to missing cursor'));
          try {
            storage[cacheName][cursor.key] = cursor.value;
            if (cursor.value.content) storage[cacheName][cursor.key].content = cursor.value.content.toString(encoding);
            else cursor.value.func = storage[cacheName][cursor.key].func = cursor.value.func.toString(encoding);
            if (remove) {
              const reqDel = cursor.delete();
              dels.push({ cacheName, key: cursor.key, promise: new Promise((resolve, reject) => {
                reqDel.onerror = reject(event.error);
                reqDel.onsuccess = () => resolve();
              })});
            } else {
              if (log &amp;&amp; (log.info || log.debug)) {
                (log.debug || log.info)(`DB: 📖 Completed "get" on "${cacheName}" for IndexedDB key "${cursor.key}"`
                  + ` (${isCompile ? 'compile' : 'render'}-time)${log.debug ? ` with: ${JSON.stringify(cursor.value)}` : ''}`);
              }
              if (typeof storage[cacheName][cursor.key].func === 'string') {
                try {
                  storage[cacheName][cursor.key].func = (new Function(`return ${storage[cacheName][cursor.key].func}`))();
                } catch (errf) {
                  errd(errf, cacheName, `Unable to deserialize function "${storage[cacheName][cursor.key].func.name}"`);
                }
              }
              if (hasRecordfunc) recordfunc(storage, cacheName, cursor.key, params, storage[cacheName][cursor.key]);
            }
          } catch (err) {
            errd(err, cacheName);
          } finally {
            cursor.continue();
          }
        })(storeName);
      }
    } else if (idbName === 'LevelUP') {
      if (!storage.db.dbs.isOpen()) {
        if (log &amp;&amp; log.info) log.info(`DB: 🏦 Opening "${idbName}" from module "${dbTypeName}" using policy "${policy}"${name ? ` while processing "${name}"` : ''}`);
        try {
          await storage.db.dbs.open();
        } catch (err) {
          if (log &amp;&amp; log.error) log.error(err);
          return end(err);
        }
        if (typeof openFunc === 'function') openFunc(storage);
      }
      if (openOnly) return end();
      if (name) { // single record processing
        try {
          if (remove) {
            await storage.db.dbs.del(name);
            delete storage[dbDStore][name];
            delete storage[dbSStore][name];
            if (hasRecordfunc) {
              recordfunc(storage, dbDStore, name, params);
              recordfunc(storage, dbSStore, name, params);
            }
            if (log &amp;&amp; log.info) log.info(`DB: ❌ Completed "delete" for LevelDB key "${name}" (${isCompile ? 'compile' : 'render'}-time)`);
            return end();
          }
          let val;
          if (valType !== 'undefined') {
            val = valueOrRemove;
            await storage.db.dbs.put(name, JSON.stringify(val));
            if (log &amp;&amp; (log.info || log.debug)) {
              const hasContent = val.hasOwnProperty('content'), storeName = hasContent ? dbDStore : dbSStore;
              (log.debug || log.info)(`DB: ✔️ Completed "put" on "${storeName}" for LevelDB key "${name}"`
                + ` (${isCompile ? 'compile' : 'render'}-time)${log.debug ? ` with: ${JSON.stringify(val)}` : ''}`);
            }
          } else {
            let rcd = await storage.db.dbs.get(name);
            if (rcd) {
              try {
                val = JSON.parse(rcd);
                const hasContent = val.hasOwnProperty('content'), storeName = hasContent ? dbDStore : dbSStore;
                if (log &amp;&amp; (log.info || log.debug)) {
                  (log.debug || log.info)(`DB: 📖 Completed "get" on "${storeName}" for LevelDB key "${name}"`
                    + ` (${isCompile ? 'compile' : 'render'}-time)${log.debug ? ` with: ${rcd}` : ''}`);
                }
              } catch (err) {
                err.message += ` &lt;- The returned result did not contain valid JSON`;
                return end(err);
              }
              if (val &amp;&amp; typeof val.func === 'string') {
                try {
                  val.func = (new Function(`return ${val.func}`))();
                } catch (err) {
                  err.message += ` &lt;- Deserialization of function "${val.func.name}" failed`;
                  return end(err);
                }
              }
            } else if (log &amp;&amp; log.info) log.info(`DB: ⚠️ Unable to "get" record for LevelDB key ${name}`);
          }
          if (val) {
            storage[val.hasOwnProperty('content') ? dbDStore : dbSStore][name] = val;
            if (hasRecordfunc) recordfunc(storage, val.hasOwnProperty('content') ? dbDStore : dbSStore, name, params, val);
          }
        } catch (err) {
          const nerr = new Error(`${err.message} &lt;- ${remove ? 'Delete' : valType !== 'undefined' ? 'Put' : 'Get'} failed for LevelDB key "${name}"`);
          nerr.message += `${err.message} &lt;- ${remove ? 'Delete' : valType !== 'undefined' ? 'Put' : 'Get'} failed for LevelDB key "${name}"`;
          nerr.stack = err.stack;
          nerr.code = err.code;
          nerr.type = err.type || err.constructor.name;
          if (log &amp;&amp; log.error) log.error(nerr);
          return end(nerr);
        }
        return end();
      } else if (log &amp;&amp; log.info) log.info(`DB: ${remove ? '❌ Removing' : '📖 Getting'} all LevelDB keys from ${storeNames.join()} using policy "${policy}"`);
      // multi-record processing
      const strm = storage.db.dbs.createReadStream(), errors = [];
      strm.on('data', async data => {
        try {
          const json = JSON.parse(data.value), hasContent = json.hasOwnProperty('content'), storeName = hasContent ? dbDStore : dbSStore;
          if (remove) {
            await storage.db.dbs.del(data.key);
            delete storage[storeName][data.key];
            if (log &amp;&amp; log.info) {
              log.info(`DB: ❌ Completed "delete" on "${storeName}" for LevelDB key "${data.key}" (${isCompile ? 'compile' : 'render'}-time)`);
            }
            if (hasRecordfunc) recordfunc(storage, storeName, data.key, params);
          } else {
            if (log) {
              if (storage[storeName][data.key] &amp;&amp; log.warn){
                log.warn(`DB: ⚠️ The template  ${storeName} for "${data.key}" is overridden by LevelDB registration`);
              } else if (log.info || log.debug) {
                (log.debug || log.info)(`DB: 📖 Completed "get" on "${storeName}" for LevelDB key "${data.key}"`
                  + ` (${isCompile ? 'compile' : 'render'}-time)${log.debug ? ` with: ${data.value}` : ''}`);
              }
            }
            storage[storeName][data.key] = json;
            if (json &amp;&amp; typeof storage[storeName][data.key].func === 'string') {
              try {
                storage[storeName][data.key].func = (new Function(`return ${storage[storeName][data.key].func}`))();
              } catch (err) {
                err.message += ` &lt;- Deserialization of function "${storage[storeName][data.key].func.name}" failed`;
                throw err;
              }
            }
            if (hasRecordfunc) recordfunc(storage, storeName, data.key, params, storage[storeName][data.key]);
          }
        } catch (err) {
          err.message = `${err.message || ''} &lt;- ${remove ? 'Removal' : 'Capture'} of template partial or source failed for LevelDB key "${data.key}".`
            + ' The entry did not contain JSON or could not be set on return object';
          errors.push(err);
          if (log &amp;&amp; log.error) log.error(err);
        }
      });
      strm.on('error', err => {
        err.message = `${err.message || ''} &lt;- ${remove ? 'Removal' : 'Capture'} of template data and/or sources failed for when reading LevelDB keys`;
        errors.push(err);
        if (log &amp;&amp; log.error) log.error(err);
      });
      strm.on('end', () => {//console.log(`END::: Name: "${name}", remove: ${remove}, put: ${valType !== 'undefined'}, errors: ${errors}`);
        if (errors.legnth) {
          var error;
          if (errors.legnth === 1) error = errors[0];
          else {
            error = new Error(`${errors.legnth} errors occurred during LevelDB ${remove ? 'removal' : 'capture'}`
              + '(see "error.errors" and "error.reads" for more details)');
            error.errors = errors;
          }
          error.reads = { [dbDStore]: storage[dbDStore], [dbSStore]: storage[dbSStore] };
          return end(error);
        }
        return end();
      });
    } else if (storage.db &amp;&amp; storage.dbs) {
      return end(new Error(`Unsupported IndexedDB implementation specified for: ${idbName}`));
    }
  });
}

/**
 * Closes a DB connection and clears the DB in the `store`
 * @private
 * @ignore
 * @param {Object} store The storage that contains the DB
 * @param {(TemplateDBOpts | Function)} optional Either the options or a `function(name:String):*` that returns an
 * option value by name
 * @param {Object} [log] The log that can contain functions for each of the following: `error`/`warn`/`info`/`debug`.
 * @param {Boolean} [isCompile] `true` when execution is for compilation, _falsy_ when rendering
 */
async function closeDB(store, optional, log, isCompile) {
  const db = store.db &amp;&amp; (store.db.idb || store.db.dbs);
  if (db &amp;&amp; typeof db.close === 'function') {
    await db.close();
    if (log &amp;&amp; log.info) log.info(`DB: 🔌 Closed connection (${isCompile ? 'compile' : 'render'}-time)`);
  }
  store.db = null; // need to clear the DB to prevent possible serialization of the DB store
}

// private mapping substitute until the following is adopted: https://github.com/tc39/proposal-class-fields#private-fields
let map = new WeakMap();
let internal = function(object) {
  if (!map.has(object)) map.set(object, {});
  return {
    at: map.get(object),
    this: object
  };
};</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<div id="jsdocpChangelogContent" data-title="CHANGELOG v1.0.0">
  <svg class="jsdocp-close" id="jsdocpChangelogClose" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
  </svg>
  <h2><a href="https://github.com/ugate/templeo/tree/v1.0.0">1.0.0</a> (2019-12-16)</h2>
<p><a href="https://github.com/ugate/templeo/compare/v1.0.0...v1.0.0">Full Changelog</a></p>
</div>



<script src="jsdocp/scripts/index.js"></script></body>
</html>
