<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>lib/cachier.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  <!-- https://realfavicongenerator.net/ -->
  
    <link
      
      rel="apple-touch-icon" 
      
      sizes="180x180" 
      
      href="apple-touch-icon.png" 
      
    >
  
    <link
      
      rel="icon" 
      
      type="image/png" 
      
      sizes="32x32" 
      
      href="favicon-32x32.png" 
      
    >
  
    <link
      
      rel="icon" 
      
      type="image/png" 
      
      sizes="16x16" 
      
      href="favicon-16x16.png" 
      
    >
  
    <link
      
      rel="manifest" 
      
      href="site.webmanifest" 
      
    >
  
    <link
      
      rel="mask-icon" 
      
      type="image/png" 
      
      sizes="16x16" 
      
      href="safari-pinned-tab.svg" 
      
      color="#ffab40" 
      
    >
  
    <link
      
      type="text/css" 
      
      rel="stylesheet" 
      
      href="pkg-styles/pkg-style.css" 
      
    >
  

  
    <meta
      
      name="msapplication-TileColor" 
      
      content="#ffab40" 
      
    >
  
    <meta
      
      name="theme-color" 
      
      content="#bdbdbd" 
      
    >
  
    <meta
      
      name="viewport" 
      
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" 
      
    >
  

  <link type="text/css" rel="stylesheet" href="jsdocp/styles/index.css"></head>
<body><div id="jsdocpNav" class="jsdocp-remove-me pkg-menu"
  data-jsdocp-sm-position="bottom"
  data-jsdocp-md-position="bottom"
  data-jsdocp-lg-position="top"
  data-jsdocp-sm-match-media="(max-width: 480px)"
  data-jsdocp-md-match-media="(min-width: 481px) and (max-width: 839px)"
  data-jsdocp-lg-match-media="(min-width: 840px)"
  data-jsdocp-sm-auto-hide="true"
  data-jsdocp-md-auto-hide="true"
  data-jsdocp-lg-auto-hide="false">
  <a href="index.html" id="jsdocpLogo"
    title="templeo"
    class="jsdocp-logo ">
    <b class="pkg-logo">
    
      <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg viewBox="0 0 64 64" width="64" height="64" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <g transform="matrix(1.9935723,0,0,2.0019177,0.08877553,-0.18261032)">
    <g transform="scale(0.96670978,1.0344366)">
      <path d="m 18.634766,5.4023438 c -1.733459,-10e-8 -3.228867,0.5041519 -4.361328,1.5253906 -1.122892,1.0122398 -1.705079,2.3995654 -1.705079,3.9902346 0,0.759851 0.195452,1.57394 0.558594,2.453125 a 0.65860366,0.65860366 0 0 0 0.0039,0.0059 c 0.1107,0.261137 0.17007,0.433699 0.242188,0.626953 -0.412293,-0.119387 -0.811529,-0.335937 -1.234375,-0.335937 -0.57709,0 -1.150057,0.112763 -1.708984,0.326172 a 0.65860366,0.65860366 0 0 0 -0.0059,0.002 c -1.1883607,0.467219 -2.0975223,1.32863 -2.6171874,2.490234 l 0.00195,0 c -0.2754091,0.612021 -0.4199219,1.244178 -0.4199219,1.878906 0,0.586308 0.1172738,1.166119 0.34375,1.722657 2.469e-4,6.06e-4 -2.472e-4,0.0013 0,0.002 0.4616675,1.174144 1.1678027,2.049935 2.1289062,2.474609 a 0.65860366,0.65860366 0 0 0 0.00781,0.0039 c 0.8286494,0.352413 1.5586814,0.548829 2.2304684,0.548829 0.586313,0 1.170378,-0.116216 1.740235,-0.339844 1.181788,-0.458451 2.082653,-1.322653 2.601562,-2.488282 0.330502,-0.705376 0.488282,-1.498294 0.488282,-2.353515 0,-0.214294 -0.0234,-0.559044 -0.06836,-1.134766 -0.04332,-0.676666 -0.248075,-1.447023 -0.591797,-2.357422 a 0.65860366,0.65860366 0 0 0 -0.0039,-0.01367 c -0.215809,-0.535206 -0.423732,-1.120249 -0.625,-1.75 -0.190291,-0.60397 -0.279297,-1.133312 -0.279297,-1.585938 0,-1.026584 0.278067,-1.7499346 0.820313,-2.3066406 a 0.65860366,0.65860366 0 0 0 0.002,-0.00195 c 0.542177,-0.5638645 1.235121,-0.8457031 2.236328,-0.8457031 1.04226,0 1.792542,0.302684 2.402344,0.9199219 a 0.65860366,0.65860366 0 0 0 0.0039,0.00195 c 0.606572,0.606572 0.90625,1.3689279 0.90625,2.4335939 0,1.572702 -0.589605,3.408904 -1.837891,5.498047 a 0.65860366,0.65860366 0 0 0 -0.002,0 c -1.320121,2.215588 -2.011719,4.290309 -2.011719,6.228515 0,1.135656 0.404802,2.137499 1.199219,2.810547 a 0.65860366,0.65860366 0 0 0 0.0039,0.0039 c 0.75835,0.631956 1.698343,0.957031 2.716797,0.957031 1.227821,0 2.438439,-0.64332 3.644531,-1.773438 a 0.65860366,0.65860366 0 0 0 0.03711,-0.921875 L 24.611328,23.130859 A 0.65860366,0.65860366 0 0 0 23.6875,23.078125 c -0.83238,0.732494 -1.487863,1.012762 -1.851562,1.015625 -0.490025,-0.0128 -0.768941,-0.128804 -0.923829,-0.271484 -0.154694,-0.142502 -0.25969,-0.35908 -0.27539,-0.78711 0.0033,-1.431752 0.595963,-3.259206 1.855469,-5.439453 1.332579,-2.306741 2.033203,-4.364066 2.033203,-6.207031 -10e-7,-1.7094646 -0.553007,-3.1902892 -1.650391,-4.2988282 -1.096122,-1.1162349 -2.559684,-1.6875 -4.240234,-1.6875 z M 12.125,16.433594 c 0.207579,0 0.558685,0.07879 1.007812,0.279297 a 0.65860366,0.65860366 0 0 0 0.0039,0.002 c 0.325823,0.142905 0.588789,0.418207 0.804687,0.976562 a 0.65860366,0.65860366 0 0 0 0.002,0.0059 c 0.09694,0.242349 0.140625,0.469511 0.140625,0.695312 0,0.206742 -0.07961,0.56478 -0.279296,1.021484 -1.7e-4,3.8e-4 -0.0018,-3.79e-4 -0.002,0 -0.141144,0.315308 -0.416373,0.578316 -0.976562,0.794922 -0.255126,0.09921 -0.487088,0.142578 -0.712891,0.142578 -0.211018,0 -0.561402,-0.07771 -1.003906,-0.265624 -0.303312,-0.138564 -0.572345,-0.422337 -0.798828,-0.996094 -0.09779,-0.252742 -0.142578,-0.486321 -0.142578,-0.710938 0,-0.21264 0.07548,-0.556983 0.265625,-0.99414 9.3e-5,-2.15e-4 0.0019,2.15e-4 0.002,0 0.141518,-0.316151 0.419067,-0.583253 0.982422,-0.808594 0.243294,-0.09732 0.47252,-0.142578 0.707031,-0.142578 z" />
    </g>
    <g transform="scale(0.805326,1.2417332)">
      <path d="m 29.052173,23.815766 0.951868,0 q 1.903736,0 2.474857,-0.584719 0.584719,-0.584719 0.584719,-2.529249 l 0,-3.372332 q 0,-2.121306 0.611915,-3.086772 0.611915,-0.965466 2.121306,-1.332615 -1.509391,-0.339953 -2.121306,-1.305419 -0.611915,-0.965466 -0.611915,-3.1003697 l 0,-3.3723321 q 0,-1.9309321 -0.584719,-2.515651 -0.571121,-0.598317 -2.474857,-0.598317 l -0.951868,0 0,-1.9445302 0.856682,0 q 3.38593,0 4.514573,1.0062604 1.142242,0.9926623 1.142242,3.9978453 l 0,3.2635472 q 0,2.0261191 0.734298,2.8148091 0.734298,0.775093 2.66523,0.775093 l 0.843083,0 0,1.94453 -0.843083,0 q -1.930932,0 -2.66523,0.788691 -0.734298,0.78869 -0.734298,2.842005 l 0,3.249949 q 0,3.005183 -1.142242,4.011444 -1.128643,1.00626 -4.514573,1.00626 l -0.856682,0 0,-1.958128 z" />
    </g>
    <g transform="scale(0.80532598,1.2417332)">
      <path d="m 10.700812,23.861077 0,1.958128 -0.8430829,0 q -3.3859302,0 -4.5417698,-1.00626 -1.1422415,-1.006261 -1.1422415,-4.011444 l 0,-3.249949 q 0,-2.053315 -0.7342981,-2.842005 -0.7342982,-0.788691 -2.66523025,-0.788691 l -0.82948492,0 0,-1.94453 0.82948492,0 q 1.94453025,0 2.66523025,-0.775093 0.7342981,-0.78869 0.7342981,-2.8148091 l 0,-3.2635472 q 0,-3.0051831 1.1422415,-3.9978453 1.1558396,-1.00626042 4.5417698,-1.00626042 l 0.8430829,0 0,1.94453022 -0.9246715,0 q -1.917334,0 -2.5020529,0.598317 -0.5847189,0.598317 -0.5847189,2.5156509 l 0,3.3723321 q 0,2.1349038 -0.6255132,3.1003698 -0.6119151,0.965466 -2.1077075,1.305419 1.5093905,0.367149 2.1213056,1.332615 0.6119151,0.965466 0.6119151,3.086772 l 0,3.372332 q 0,1.917334 0.5847189,2.515651 0.5847189,0.598317 2.5020529,0.598317 l 0.9246715,0 z" />
    </g>
  </g>
</svg>

    
    </b>
    <b id="jsdocpPkgName">templeo</b>
    <b>|</b>
    <hr/>
  </a>
  <a href="https://www.npmjs.com/package/templeo" id="jsdocpModule"
    title="npm"
    class="jsdocp-icon ">
    
    <svg version="1.1" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
      <g class="jsdocp-icon-svg-el pkg-icons" stroke="none" transform="translate(0,24) scale(0.1,-0.1)">
        <path d="M 0,120 0,0 l 120,0 120,0 0,120 0,120 -120,0 -120,0 z m 200,0 c 0,-73 0.23256,-80 0.23256,-80 0,0 -27.97435,0.741211 -40.61273,0.707427 C 159.61983,67.551504 160,70.949947 160,100 c 0,53 -2,60 -20,60 -18,0 -20,-7 -20,-60 l 0,-60 -40,0 -40,0 0,80 0,80 80,0 80,0 z"/>
      </g>
    </svg>
    
  </a>
  <a href="CHANGELOG.html" id="jsdocpChangelog" data-jsdocp-root-href="https://github.com/ugate/templeo/CHANGELOG.html"
    title="Changelog"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 64 64" height="64" width="64" xmlns="http://www.w3.org/2000/svg">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="M 29.896194,0.97873581 C 13.435048,0.97873581 1.1072664e-7,15.139296 0,32.489368 0,49.839439 13.435048,64 29.896194,64 46.357339,64 59.792385,49.839438 59.792388,32.489368 a 4.2273908,4.4556761 0 1 0 -8.453721,0 c -10e-7,12.534501 -9.550175,22.600399 -21.442473,22.600399 -11.892299,0 -21.4424739,-10.065899 -21.4424739,-22.600399 0,-12.5345 9.5501749,-22.6003988 21.4424739,-22.6003988 a 4.2273908,4.4556761 0 1 0 0,-8.91023339 z" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 55.529412,24.680907 -8.470588,10.142582 16.941176,0 z"/>
      <rect class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        transform="matrix(0.6882785,0.72544656,-0.6882785,0.72544656,0,0)" y="-38.592953" x="38.592953" height="39.814472" width="11.375563" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 23.705056,39.295314 8.338477,-1.11407 -7.281487,-7.674698 z"/>
    </svg>
    
  </a>
  <a href="https://github.com/ugate/templeo#readme" id="jsdocpSourceCode"
    title="Source Code"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 10 16" width="24" height="24" xmlns="http://www.w3.org/2000/svg" id="jsdocpSourceIcon">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="evenodd"
        d="M8 1a1.993 1.993 0 0 0-1 3.72V6L5 8 3 6V4.72A1.993 1.993 0 0 0 2 1a1.993 1.993 0 0 0-1 3.72V6.5l3 3v1.78A1.993 1.993 0 0 0 5 15a1.993 1.993 0 0 0 1-3.72V9.5l3-3V4.72A1.993 1.993 0 0 0 8 1zM2 4.2C1.34 4.2.8 3.65.8 3c0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm3 10c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm3-10c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2z"></path>
    </svg>
    <!-- GitHub icon -->
    <svg version="1.1" viewBox="0 0 16 16" height="24" width="24" xmlns="http://www.w3.org/2000/svg" class="jsdocp-remove-me" id="jsdocpGithubIcon">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none"  fill-rule="evenodd"
        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
    </svg>
    
  </a>
  <!-- versions.json should point to the latest list -->
  <a id="jsdocpVersionsIcon"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 64 64" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 63.999999,25.315556 -24.108295,0 9.74288,-10.026667 C 39.927261,5.6888885 24.210644,5.3333335 14.503322,14.933333 c -9.7073234,9.635555 -9.7073234,25.173334 0,34.808888 9.707322,9.635556 25.423939,9.635556 35.131262,0 4.835883,-4.764443 7.253823,-10.346666 7.253823,-17.386666 l 7.111592,0 c 0,7.039999 -3.1291,16.177777 -9.387301,22.364444 -12.480844,12.373334 -32.748879,12.373334 -45.2297224,0 -12.445286,-12.337778 -12.55196,-32.39111 -0.071116,-44.7288881 12.4808434,-12.3377774 32.4999734,-12.3377774 44.9808174,0 L 64,-5e-7 64,25.315556 Z" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 33.775734,17.777777 0,15.111111 12.445286,7.395556 -2.560173,4.302222 -15.218806,-9.031112 0,-17.777777 5.333693,0 z" />
    </svg>
    
  </a>
  <select id="jsdocpVersions"
    title="v1.0.0"
    data-jsdocp-version-base="/templeo"
    data-jsdocp-json-url="/templeo/versions.json"
    data-jsdocp-type=""
    data-jsdocp-from="1.0.0"
    data-jsdocp-version="1.0.0">
  </select>
</div>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Tutorials</li><li class="nav-item"><a href="tutorial-1-basics.html">The Basics</a></li><li class="nav-item"><a href="tutorial-2-cache.html">Cache</a></li><li class="nav-item"><a href="tutorial-3-examples.html">Examples</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Cachier.html">Cachier</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#.contentURL">contentURL</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#.waiter">waiter</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#clear">clear</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#compile">compile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#getRegistered">getRegistered</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#modules">modules</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#read">read</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#readWriteName">readWriteName</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#register">register</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#registerHelper">registerHelper</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#registerPartial">registerPartial</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#unregister">unregister</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Cachier.html#write">write</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="CachierDB.html">CachierDB</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierDB.html#clear">clear</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierDB.html#compile">compile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierDB.html#read">read</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierDB.html#register">register</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierDB.html#write">write</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="CachierFiles.html">CachierFiles</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierFiles.html#clear">clear</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierFiles.html#compile">compile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierFiles.html#read">read</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierFiles.html#register">register</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CachierFiles.html#write">write</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-templeo_options-TemplateOpts.html">TemplateOpts</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo_options-TemplateOpts.html#.defaultOptionMerge">defaultOptionMerge</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo_options-TemplateOpts.html#build">build</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-templeo-Engine.html">Engine</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#.create">create</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#clearCache">clearCache</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#compile">compile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#getRegistered">getRegistered</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#register">register</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#registerHelper">registerHelper</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#registerPartial">registerPartial</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#renderPartial">renderPartial</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#renderPartialGenerate">renderPartialGenerate</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-templeo-Engine.html#unregister">unregister</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Sandbox.html">Sandbox</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sandbox.html#.compile">compile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sandbox.html#.deserialzeBlock">deserialzeBlock</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sandbox.html#.deserialzeFunction">deserialzeFunction</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sandbox.html#.guid">guid</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Sandbox.html#.serialzeFunction">serialzeFunction</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="TemplateDBOpts.html">TemplateDBOpts</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="TemplateFileOpts.html">TemplateFileOpts</a></span></li><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-templeo.html">templeo</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-templeo_options.html">templeo/options</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">lib/cachier.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const TemplateOpts = require('./template-options');
const Sandbox = require('./sandbox');
const Director = require('./director');
// TODO : ESM uncomment the following lines...
// TODO : import * as TemplateOpts from './template-options.mjs';
// TODO : import * as Sandbox from './sandbox.mjs';
// TODO : import * as Director from './director.mjs';

//let engx = new WeakMap();

/**
 * The default persistence cache manager that uses a simple object mapping for {@link Cachier.read}/{@link Cachier.write}
 * operations. All caching is maintained in-memory. Template, partial and context {@link Cachier.read} operations use
 * either `window.fetch` (browsers) or the `https` module (Node.js) to capture partial template content. Compiled template
 * {@link Cachier.read} operations are handled via _dynamic_ `import`/`require` (if used). {@link Cachier.write} operations
 * are typically written to memory, but can also be configured to `POST` template, partials and/or context over HTTP/S.
 */
class Cachier {
// TODO : ESM use... export class Cachier {

  /**
   * Constructor
   * @param {TemplateOpts} [opts] the {@link TemplateOpts}
   * @param {Function} [readFormatter] The `function(string, readFormatOptions)` that will return a formatted string for __reading__
   * data using the `options.readFormatOptions` from {@link TemplateOpts} as the formatting options. Typically reads are for __HTML__
   * _minification_ and/or _beautifying_. __NOTE: Use with caution as syntax errors may result depending on the formatter used and the
   * complexity of the data being formatted!__ 
   * @param {Function} [writeFormatter] The `function(string, writeFormatOptions)` that will return a formatted string for __writting__
   * data using the `options.writeFormatOptions` from {@link TemplateOpts} as the formatting options. Typically reads are for __JS__
   * _minification_ and/or _beautifying_. __NOTE: Use with caution as syntax errors may result depending on the formatter used and the
   * complexity of the data being formatted!__ 
   * @param {Object} [log] The log for handling logging output
   * @param {Function} [log.debug] A function that will accept __debug__ level logging messages (i.e. `debug('some message to log')`)
   * @param {Function} [log.info] A function that will accept __info__ level logging messages (i.e. `info('some message to log')`)
   * @param {Function} [log.warn] A function that will accept __warning__ level logging messages (i.e. `warn('some message to log')`)
   * @param {Function} [log.error] A function that will accept __error__ level logging messages (i.e. `error('some message to log')`)
   */
  constructor(opts, readFormatter, writeFormatter, log = {}) {
    const ns = internal(this);
    const options = opts instanceof TemplateOpts ? opts : new TemplateOpts(opts);
    ns.at.options = options;
    ns.at.log = log || {};
    ns.at.readFormatter = typeof readFormatter === 'function' ? readFormatter : null;
    ns.at.writeFormatter = typeof writeFormatter === 'function' ? writeFormatter : null;
    initCache(ns.at);
  }

  /**
   * Registers a _directive_ function that can be used within template
   * [interpolations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Expression_interpolation)
   * @param {Function} func A __named__ `function` that has no external scope dependencies/closures other than those exposed
   * via templates during rendering
   */
  registerHelper(func) {
    const ns = internal(this);
    ns.at.helpers.add(func);
  }

  /**
   * Unregisters a partial template from cache
   * @param {String} name The template name that uniquely identifies the template content
   */
  async unregister(name) {
    const ns = internal(this);
    if (ns.at.data[name]) delete ns.at.data[name];
    if (ns.at.sources[name]) delete ns.at.sources[name];
  }

  /**
   * Registers and stores a partial template __in-memory__. Use {@link Cachier.register} to write partials to cache ({@link Cachier})
   * @param {String} name The __raw__ template name (i.e. not from {@link Cachier.readWriteName})
   * @param {(String | URLSearchParams)} contentOrParams Either the partial template content __string__ to register _or_ the
   * `URLSearchParams` that will be passed during the content `read`
   * @param {String} [extension=options.defaultExtension] Optional override for a file extension designation for the partial
   * @returns {String} The partial content
   */
  async registerPartial(name, contentOrParams, extension) {
    const ns = internal(this), opts = ns.this.options, ext = (extension &amp;&amp; String(extension)) || opts.defaultExtension || '', log = ns.this.log;
    const params = contentOrParams instanceof URLSearchParams ? params : null;
    const contentType = !params &amp;&amp; typeof contentOrParams;
    const path = await ns.this.readWriteName(name, opts, params, ns.at, true, extension);
    if (log.info) log.info(`CACHE: 🏧 Registering template "${name}" @ "${path}" (compile-time)`);
    ns.at.data[path] = { name: path };
    ns.at.data[path].extension = ext;
    if (params) {
      ns.at.data[path].params = contentOrParams;
    } else if (contentType === 'string') {
      ns.at.data[path].content = contentOrParams;
    } else if (contentType === 'object' &amp;&amp; extension === 'json') {
      ns.at.data[path].content = JSON.parse(JSON.stringify(contentOrParams));
    }
    return ns.at.data[path].content;
  }

  /**
   * Retrieves a template, partial or context that resides __in-memory__.
   * @param {String} name The __raw__ template name (i.e. not from {@link Cachier.readWriteName})
   * @param {URLSearchParams} [params] Any parameters designated during {@link Cachier.registerPartial}
   * @param {String} [extension=options.defaultExtension] Optional override for a file extension designation
   * for the template, partial or context designated during {@link Cachier.registerPartial}
   * @returns {Object} A copy of the generated data from {@link Cachier.registerPartial}
   */
  async getRegistered(name, params, extension) {
    const ns = internal(this), opts = ns.this.options, prms = params instanceof URLSearchParams ? params : null;
    const path = await ns.this.readWriteName(name, opts, prms, ns.at, true, extension);
    return (path &amp;&amp; ns.at.data[path] &amp;&amp; JSON.parse(JSON.stringify(ns.at.data[path]))) || null;
  }

  /**
   * Registers and __caches__ the template, one or more partial templates and/or context JSON.
   * @param {Object[]} [data] The template, partials and/or context to register.
   * @param {String} data[].name The name that uniquely identifies the template, partial or context
   * @param {String} [data[].content] The raw content that will be registered. Omit when `read === true` to read content from cache.
   * @param {URLSearchParams} [data[].params] The `URLSearchParams` that will be passed during the content `read`
   * (__ignored when `content` is specified__).
   * @param {String} [data[].extension] Optional override for a file extension designated for a template, partial or context.
   * @param {Boolean} [read] When `true`, an attempt will be made to also {@link Cachier.read} the template, partials and context that
   * __do not have__ a `content` property set.
   * @param {Boolean} [write] When `true`, an attempt will be made to also {@link Cachier.write} the template, partials and context that
   * __have__ a `content` property set.
   * @returns {Object} An object that contains the registration results:
   * 
   * - `data` The object that contains the template, partial fragments and/or context that have been registered
   *   - `name` The name that uniquely identifies the template, partial or context
   *   - `content` The raw content of the template, partial or context
   *   - `extension` The template file extension designation
   *   - `params` The URLSearchParams passed during the __initial__ content read
   *   - `fromRead` A flag that indicates that the data was set from a read operation
   */
  async register(data, read, write) {
    const ns = internal(this), opts = ns.this.options;
    const rtn = { data: [] }; // data should not be "new Array(data.length)" since more may be added by extending classes
    if (!data) return rtn;
    let content, params, pidx = -1, ext;
    for (let dta of data) {
      pidx++;
      ext = dta.extension &amp;&amp; String(dta.extension) || (dta.name === opts.defaultContextName ? opts.defaultContextExtension : opts.defaultExtension) || '';
      if (!dta.hasOwnProperty('name')) {
        throw new Error(`Template, partial or context "name" missing at index ${pidx} for ${JSON.stringify(dta)}`);
      }
      params = dta.params instanceof URLSearchParams ? dta.params : null;
      if (!dta.hasOwnProperty('content')) {
        if (read) {
          content = await ns.this.read(dta.name, true, ext, params);
          content = content ? content.content : undefined;
        } else content = null;
        if (typeof content !== 'string') {
          const urld = Cachier.contentURL(dta.name, opts);
          const errMsg = `Template, partial or context "content" missing at index ${pidx} for ${JSON.stringify(dta)}`
            + `${read &amp;&amp; !urld.url ? ` - "options.${urld.optionName}" should be set to a valid URL to fetch the content from` : ''}`;
          try {
            // validate the name/URL for consistency with render-time errors
            new URL(dta.name, urld.url || undefined);
          } catch (err) {
            err.message = `${err.message} &lt;- ${errMsg}`;
            throw err;
          }
          throw new Error(errMsg);
        }
      } else {
        content = dta.content;
        if (write) await ns.this.write(dta.name, content, true, ext);
      }
      await ns.this.registerPartial(dta.name, typeof content !== 'undefined' ? content : dta.params, ext);
      rtn.data.push({ name: dta.name, content, extension: ext, params });
    }
    return rtn;
  }

  /**
   * Compiles a locally sandboxed `async` template rendering function and when applicable, stores the function in cache
   * @param {String} name The template name that uniquely identifies the primary template content
   * @param {(String | Boolean)} [template] The raw template content, `true` to read from cache before compilation.
   * Omit to load the template content from cache when the returned rendering function is called.
   * @param {URLSearchParams} [params] Any URL search parmeters that will be passed when capturing the primary `template` and/or `context` when needed
   * @param {String} [extension] The file extension designation for the template
   * @returns {Function} The return function from {@link Sandbox.compile}
   */
  async compile(name, template, params, extension) {
    const ns = internal(this), opts = ns.this.options, log = ns.this.log;
    let content = template, cnm, func;
    if (template === true) { // read/load primary template source
      let rd;
      cnm = await ns.this.readWriteName(name, opts, params, ns.at, true, extension);
      if (!opts.cacheRawTemplates || !ns.at.data[cnm] || !ns.at.data[cnm].hasOwnProperty('content')) {
        rd = await ns.this.read(name, true, extension, params);
        content = rd &amp;&amp; (rd.hasOwnProperty('content') ? rd.content : rd.data &amp;&amp; rd.data[cnm] ? rd.data[cnm].content : null);
        if (typeof content !== 'string') {
          throw new Error(`Unable to find/read primary template @ "${name}" (full name: "${cnm}") using options: ${JSON.stringify(opts)}`);
        }
        await ns.this.registerPartial(cnm, content);
      } else content = ns.at.data[cnm].content;
      if (content) { // only read rendering function when there is corresponding content
        const snm = await ns.this.readWriteName(name, opts, params, ns.at, false);
        if (!opts.cacheRawTemplates || !ns.at.sources[snm] || !ns.at.sources[snm].hasOwnProperty('func')) {
          try {
            rd = await ns.this.read(name, false, extension, params);
            func = rd &amp;&amp; rd.func;
          } catch (err) {
            if (log.warn) log.warn(err);
          }
        } else func = ns.at.sources[snm].func;
      }
    }
    if (!func) { // no rendering function requires a fresh compile
      func = Sandbox.compile(name, content, opts, ns.this.readWriteNames, ns.this.operations, ns.at.helpers, ns.this.metadata, log);
      if (log.debug) log.debug(`CACHE: 📦 Created sandbox for: ${Sandbox.serialzeFunction(func)}`);
      if (func) {
        if (opts.renderTimePolicy.includes('write')) {
          const cmod = await ns.this.write(name, func, false, null, params);
          if (typeof cmod === 'function') func = cmod;
        }
        if (log.info) log.info(`CACHE: 📦 Compiled template named "${func.name}"${cnm ? ` @ "${cnm}"` : ''}`);
      }
    }
    return func;
  }

  /**
   * Reads either template content or template code from internal cache.
   * When `options.partialsURL` is set to an HTTPS URL and the read is for partial content, A `GET` call to `window.fetch` is made
   * when running within browsers or to the `https` module when running on the server. The partial `name` will be appended to
   * `options.partialsURL` (e.g. `https://example.com/some/id.html` where `some/id.html` is the the partial's
   * {@link Cachier.readWriteName} and `options.partialsURL` is set to `https://example.com`). When `options.partialsURL` is
   * omitted _reading_ of template partial content will be limited to _reading_ from memory. Compiled template source code is _always_
   * _read_ from memory __only__.
   * @param {String} name The template name that uniquely identifies the template content
   * @param {Boolean} [forContent] `true` to read a template content, `false` to read the template source code
   * @param {String} [extension] The file extension designation (only used when `forContent` is truthy)
   * @param {URLSearchParams} [params] The `URLSearchParams` to pass for the read (only used when `forContent` is truthy)
   * @returns {Object} An object read from cache that contains either the template content or module.
   * 
   * Returned template content properties:
   * - `name` The template name that uniquely identifies the template content
   * - `content` The template content
   * - `extension` The template file extension designation
   * 
   * Returned module properties:
   * - `name` The template name that uniquely identifies the template content
   * - `func` The module function generated from the code
   */
  async read(name, forContent, extension, params) {
    const ns = internal(this), opts = ns.this.options, log = ns.this.log;
    const path = await ns.this.readWriteName(name, opts, params, ns.at, forContent, extension);
    return readAndSet(await modules(opts), name, path, ns.at, forContent, extension, opts, params, false, ns.this, log, true);
  }

  /**
   * Writes either template content or template code from internal cache.
   * When `options.partialsURL` is set to an HTTPS URL and the read is for partial content, A `POST` call to `window.fetch` is made
   * when running within browsers or to the `https` module when running on the server. The partial `name` will be appended to
   * `options.partialsURL` (e.g. `https://example.com/some/id.html` where `some/id.html` is the the partial's
   * {@link Cachier.readWriteName} and `options.partialsURL` is set to `https://example.com`). When `options.partialsURL` is
   * omitted _writting_ of template partial content will be limited to _writes_ to memory. Compiled template source code is _always_
   * _written_ to memory __only__.
   * @param {String} name The template name that uniquely identifies the template content
   * @param {(String|Function)} data The data to write. For content, `data` should be a string. Otherwise `data` should be a function or
   * a function string.
   * @param {Boolean} [forContent] `true` to read a template content, `false` to read the template source code
   * @param {String} [extension] The file extension designation (only used when `forContent` is truthy)
   * @param {URLSearchParams} [params] The `URLSearchParams` to pass for the write (only used when `forContent` is truthy)
   * @returns {(Function | undefined)} Optionally return the compiled/written module function
   */
  async write(name, data, forContent, extension, params) {
    const ns = internal(this), opts = ns.this.options, log = ns.this.log;
    const path = await ns.this.readWriteName(name, opts, params, ns.at, forContent, extension);
    return writeAndSet(await modules(opts), name, path, opts, params, ns.at, data, forContent, extension, ns.this, log, true);
  }

  /**
   * @returns {TemplateOpts} The template compile options
   */
  get options() {
    const ns = internal(this);
    return ns.at.options;
  }

  /**
   * @protected
   * @returns {Object} The compilation metadata that will be passed into {@link Sandbox.compile}
   */
  get metadata() {
    const ns = internal(this);
    return {
      data: JSON.parse(JSON.stringify(ns.at.data))
      //,sources: JSON.parse(JSON.stringify(ns.at.sources))
    };
  }

  /**
   * @returns {Function} The __read__ formatting function that takes 1 or 2 arguments with the first being the content
   * that will be formatted and the second being `options.readFormatOptions`
   */
  get readFormatter() {
    const ns = internal(this);
    return ns.at.readFormatter;
  }

  /**
   * @returns {Function} The __write__ formatting function that takes 1 or 2 arguments with the first being the content
   * that will be formatted and the second being `options.writeFormatOptions`
   */
  get writeFormatter() {
    const ns = internal(this);
    return ns.at.writeFormatter;
  }

  /**
   * @returns {Object} The optional log used by the {@link Cachier}
   */
  get log() {
    const ns = internal(this);
    return ns.at.log;
  }

  /**
   * Clears the cache
   * @param {Boolean} [all=false] `true` to clear all unassociated cache instances when possible
   */
  async clear(all = false) {
    const ns = internal(this);
    initCache(ns.at);
  }

  /**
   * @param {(TemplateOpts | Function(name:String):*)} optional Either the {@link TemplateOpts} or a function that takes a
   * single name argument and returns the option value
   * @returns {Object} The object that contains the modules used by the {@link Cachier} implementation
   */
  async modules(optional) {
    return modules;
  }

  /**
   * @returns {(Object | Object[])} [operations] One or more operation objects that will handle render-time reads/writes
   * @returns {Function} [operations[].read] The reader is an `async function` responsible for reading partial template content/modules/etc
   * during render-time when a partial template cannot be found within `includes`. When `options.cacheRawTemplates` is _truthy_ an
   * attempt will be made to add any missing/read partials into `storage.data` in order to prevent unnecessary template partial
   * reads for repeated includes. Read functions should not reference any external scope other than the global object space.
   * The following arguments will be passed:
   * 1. _{String}_ `name` The name of the partial that will be read. The read function may be invoked without a _name_ parameter when
   * the intent is to capture all partials in a single read opteration that will be included.
   * 1. _{String}_ `path` The path to the partial that will be read. The read function may be invoked without a _path_ parameter when
   * the intent is to capture all partials in a single read opteration that will be included.
   * 1. _{String}_ `ext` The path file extension to the partial that will be read. The read function may be invoked without an _ext_
   * parameter when the intent is to capture all partials in a single read opteration that will be included.
   * 1. _{Boolean}_ `forContent` The flag indicating that the read is for content. Otherwise, the read is for rendering functions.
   * 1. _{(TemplateOpts | Function(name:String):*)}_ `optional` Either the {@link TemplateOpts} or a function that takes a single name
   * argument and returns the option value.
   * 1. _{URLSearchParams}_ `[params]` The URLSearchParams that should be used during the read
   * 1. _{Object}_ `storage` The storage object that can contain metadata for read operations and should contain a __data__ object
   * that stores each of the read paratial template content/metadata.
   * 1. _{Function}_ `[formatter]` The function that will format reads/writes during include discovery (if any). The formatting function
   * takes 1 or 2 arguments with the first being the content that will be formatted and the second being `options.readFormatOptions` for
   * reads and `options.writeFormatOptions` for writes.
   * The returned result should be a valid string.
   * 1. _{Boolean}_ `[close]` A flag indicating whether or not any resources used during the read should be closed/cleaned up after the
   * read completes. Closure may be dependent upon the policy set on the options.
   * 1. _{Object}_ `[log]` A logger that can contain functions for each of the following: `error`/`warn`/`info`/`debug`.
   * 
   * Read functions can return the partial template content and/or it can be set on the `storage.data`.
   * Returning `true` will stop any further rendering from processing resulting in the rendering function returning a _blank_ string.
   * @returns {Function} [operations[].write] The write function that will be used for writting newly discovered template sources.
   * Accepts the same arguments as `operations[].read` and all _scoped_ functions will be available. Can return a __rendering__
   * function that will prevent further iteration of any subsequent `operations[].write` invocations.
   * @returns {Function} [operations[].finish] An `async function` that can perform cleanup tasks for a reader. Arguments passed are
   * `storage`, `optional` and `log` as described for `operations[].read`.
   * @returns {Function[]} [operations[].scopes] Zero or more functions that will be in scope when the read function is called.
   * Scoped functions can assit with complex read/write operations that can benefit from separate supporting functions. For example,
   * `[myFunc(){}]` could be referenced like `async function myReader(){ myFunc(); ... }`.
   */
  get operations() {
    return Object.freeze({
      read: defaultRenderReader,
      write: defaultRenderWriter,
      scopes: Object.freeze([
        fetcher,
        isAbsName,
        modules,
        initRegistrant,
        readAndSet,
        writeAndSet
      ])
    });
  }

  /**
   * Converts template names into a full path name consumable by `read`/`write` oprtations. Each function from
   * {@link Cachier.readWriteNames} will be executed in order using the same arguments as {@link Cachier.readWriteName} as well as an
   * additional last agument being the return value from the previous function invocation.
   * @param {String} name The name of the template, partial or context that will be converted into a name suitable for a read operation
   * @param {(TemplateOpts | Function(name:String):*)} optional Either the {@link TemplateOpts} or a function that takes a single name
   * argument and returns the option value
   * @param {URLSearchParams} [params] The parameters that should be used in the converted name
   * @param {Object} store The storage object that can contain metadata used by naming operations
   * @param {Boolean} forContent The flag indicating if the converted name is being used to capture partials
   * @param {String} [extension] The file extension override for the converted name (omit to use the default extension set in the options)
   * @param {Boolean} forContext The flag indicating if the converted name is being used to capture context
   * @returns {String} The full template name
   */
  async readWriteName(name, optional, params, store, forContent, extension, forContext) {
    let nmrs = this.readWriteNames;
    return nmrs.namer(nmrs, name, optional, params, store, forContent, extension, forContext);
  }

  /**
   * @see {@link Cachier.readWriteName} for parameter details
   * @returns {Object} `namers` One or more async functions responsible for formatting template names into a full path name
   * consumable by `read`/`write` oprtations
   * @returns {Object} `namers.namer` The default naming function
   * @returns {Object} `namers.namerSuper` The naming function to use when a {@link Cachier.operations} function throws an error. The next
   * reader called in the {@link Cachier.operations} list will use the name generated by this reader.
   */
  get readWriteNames() {
    return { namer: readWriteName };
  }

  /**
   * Extracts the proper URL and option name used for a particular template, partial or context
   * @param {String} name The template, partial or context name
   * @param {TemplateOpts} opts The template options
   * @returns {Object} The extracted content that contains a `url` property and a `optionName` that describes the option used for the URL
   */
  static contentURL(name, opts) {
    const rtn = {};
    if (name === opts.defaultTemplateName) {
      rtn.url = opts.templateURL;
      rtn.optionName = 'templateURL';
    } else if (name === opts.defaultContextName) {
      rtn.url = opts.contextURL;
      rtn.optionName = 'contextURL';
    } else {
      rtn.url = opts.partialsURL;
      rtn.optionName = 'partialsURL';
    }
    return rtn;
  }

  /**
   * Waits for promises to finish and throws commulative errors into a single meaningful stack while continuing to process
   * subsequent promises in the array. When an error is thrown and `capture === true`, it will also contain a `results`
   * property that contains either each result from an awaited promise or an error thrown when waiting for the promise to
   * complete.
   * @param {Promise[]} proms The promises to wait for.
   * @param {String} [errMsg='One or more pomises failed'] The message to use when any errors occur.
   * @param {Boolean} [capture=true] When `true` each promise results/errors will be captured and returned. Otherwise,
   * nothing will be captured
   * @returns {(Array | undefined)} When `capture === true`, the awaited promise results are retuend. When an error occurs,
   * the value at the given index will contain the error instead. When `capture !== true` nothing is captured/returned.
   */
  static async waiter(proms, errMsg = 'One or more pomises failed', capture = true) {
    let error, pcnt = 0, results = capture ? [] : undefined;
    for (let prom of proms) {
      pcnt++;
      try {
        if (results) results.push(await prom);
        else await prom;
      } catch (err) {
        nerr = new Error(err.constructor.name !== 'Error' ? `${err.constructor.name || 'PromiseError'}:` : '');
        nerr.code = err.code;
        nerr.stack = `${err.message}${error &amp;&amp; error.message ? ` &lt;- ${error.message}` : ''}`
        + (pcnt >= proms.length ? ` &lt;- ${errMsg}` : '')
        + `\nPROMISE #${pcnt} of ${proms.length}: \n${err.stack}${error ? `\n${error.stack}` : ''}`;
        error = nerr;
        if (results) results.push(nerr);
      }
    }
    if (error) {
      if (results) error.results = results;
      throw error;
    }
    return results;
  }
}

// TODO : ESM remove the following lines...
module.exports = Cachier;

/**
 * Default reader that reads the contents of from cache
 * @private
 * @ignore
 * @param {String} name The name of template that will be read
 * @param {String} path The path to the template that will be read
 * @param {String} ext The path extension
 * @param {Boolean} forContent The flag indicating that the read is for content. Otherwise, the read is for rendering functions.
 * @param {(TemplateDBOpts | Function)} optional Either the options or a `function(name:String):*` that returns an
 * option value by name
 * @param {URLSearchParams} [params] The search parameters to use for the read 
 * @param {Object} store The JSON storage space
 * @param {Function} [readFormatter] The formatting function to use to format the read content
 * @param {Boolean} [close] When `true`, the resources will be closed after execution is complete
 * @param {Object} [log] The log that can contain functions for each of the following: `error`/`warn`/`info`/`debug`
 * @returns {(String | undefined)} The return value from {@link readAndSet}
 */
async function defaultRenderReader(name, path, ext, forContent, optional, params, store, readFormatter, close, log) {
  if (!path) return;
  const mods = await modules(optional), reg = initRegistrant(path, optional, store, readFormatter);
  return readAndSet(mods, name, path, store, forContent, ext, optional, params, close, reg, log);
}

/**
 * Default writer that writes the contents to cache
 * @private
 * @ignore
 * @param {String} name The name of template that will be written
 * @param {String} path The path to the template that will be written
 * @param {String} ext The path extension
 * @param {Boolean} forContent The flag indicating that the write is for content. Otherwise, the write is for rendering functions.
 * @param {(TemplateDBOpts | Function)} optional Either the options or a `function(name:String):*` that returns an
 * option value by name
 * @param {URLSearchParams} [params] The search parameters to use for the write 
 * @param {Object} store The JSON storage space
 * @param {String} data The code block that will be written
 * @param {Function} [writeFormatter] The formatting function to use to format the written content
 * @param {Boolean} [close] When `true`, the resources will be closed after execution is complete
 * @param {Object} [log] The log that can contain functions for each of the following: `error`/`warn`/`info`/`debug`
 * @returns {(Function | undefined)} The return value from {@link writeAndSet}
 */
async function defaultRenderWriter(name, path, ext, forContent, optional, params, store, data, writeFormatter, close, log) {
  const mods = await modules(optional), reg = initRegistrant(path, optional, store, null, writeFormatter);
  return writeAndSet(mods, name, path, optional, params, store, data, forContent, ext, reg, log);
}

/**
 * Reads/Captures a partial template or generated rendering function
 * @private
 * @ignore
 * @param {Object} mods The return object from {@link modules}
 * @param {String} name The name of template that will be read
 * @param {String} path The path to the template that will be read
 * @param {Object} store The JSON storage space
 * @param {Boolean} forContent The flag indicating if the converted name is being used to capture partials
 * @param {String} [extension] The file extension override for the converted name (omit to use the default extension set in the options)
 * @param {(TemplateDBOpts | Function)} optional Either the options or a `function(name:String):*` that returns an
 * option value by name
 * @param {URLSearchParams} [params] The search parameters to use for the read
 * @param {Boolean} close `true` when no further reads are required
 * @param {Object} registrant The registrant {@link CachierFiles} or similar object
 * @param {Function} registrant.registerPartial The {@link CachierFiles.registerPartial} or similar function
 * @param {Function} registrant.unregister The {@link CachierFiles.unregister} or similar function
 * @param {Function} [registrant.readFormatter] The {@link CachierFiles.readFormatter} or similar function
 * @param {Function} [registrant.writeFormatter] The {@link CachierFiles.writeFormatter} or similar function
 * @param {Object} [log] The log that can contain functions for each of the following: `error`/`warn`/`info`/`debug`
 * @param {Boolean} [isCompile] `true` when execution is for compilation, _falsy_ when rendering
 * @returns {Object} The read/cached entry 
 */
async function readAndSet(mods, name, path, store, forContent, extension, optional, params, close, registrant, log, isCompile) {
  const isOptionFunc = typeof optional === 'function', isFetch = forContent &amp;&amp; (!isCompile || isAbsName(name, optional));
  if (log.info) {
    log.info(`CACHE: ${isFetch ? '📡 HTTPS' : '🏧 MEMORY'}- Reading template ${forContent ? 'partial' : 'code'} `
      + `from ${isFetch ? `GET ${path}${params ? `?${params.toString()}"` : ''}` : `module "${name}" @ "${path}"`} (${isCompile ? 'compile' : 'render'}-time)`);
  }
  const cacheName = forContent ? 'data' : 'sources';
  if (forContent) {
    let content = isFetch ? await fetcher(mods, path, optional, params, store, null, registrant.readFormatter, close, log) : 
      store[cacheName][path] &amp;&amp; store[cacheName][path].content;
    const ctype = typeof content;
    if (!isFetch &amp;&amp; ctype === 'string' &amp;&amp; registrant.readFormatter) {
      const rfopts = isOptionFunc ? optional('readFormatOptions') : optional.readFormatOptions;
      content = registrant.readFormatter(content, rfopts);
    }
    await registrant.registerPartial(name, ctype !== 'string' ? params : content, extension);
  } else {
    store[cacheName][path] = {
      name: path,
      shortName: name,
      func: store[cacheName][path] &amp;&amp; store[cacheName][path].func
    };
  }
  return store[cacheName][path];
}

/**
 * Writes/Sets a partial template or generated rendering function
 * @private
 * @ignore
 * @param {Object} mods The return object from {@link modules}
 * @param {String} name The name of template that will be written
 * @param {String} path The path to the template that will be written
 * @param {(TemplateDBOpts | Function)} optional Either the options or a `function(name:String):*` that returns an
 * option value by name
 * @param {URLSearchParams} [params] The search parameters to use for the write 
 * @param {Object} store The JSON storage space
 * @param {String} data The code block that will be written
 * @param {Boolean} forContent The flag indicating if the converted name is being used to capture partials
 * @param {String} [extension] The file extension override for the converted name (omit to use the default extension set in the options)
 * @param {Object} registrant The registrant {@link CachierFiles} or similar object
 * @param {Function} registrant.registerPartial The {@link CachierFiles.registerPartial} or similar function
 * @param {Function} registrant.unregister The {@link CachierFiles.unregister} or similar function
 * @param {Function} [registrant.readFormatter] The {@link CachierFiles.readFormatter} or similar function
 * @param {Function} [registrant.writeFormatter] The {@link CachierFiles.writeFormatter} or similar function
 * @param {Function} registrant.modularize The {@link CachierFiles.modularize} or similar function
 * @param {Object} [log] The log that can contain functions for each of the following: `error`/`warn`/`info`/`debug`
 * @param {Boolean} [isCompile] `true` when execution is for compilation, _falsy_ when rendering
 * @returns {Function | undefined} The written rendering function or `undefined` when writing partial template content
 */
async function writeAndSet(mods, name, path, optional, params, store, data, forContent, extension, registrant, log, isCompile) {
  const isOptionFunc = typeof optional === 'function', logLabel = log ? ` (${isCompile ? 'compile' : 'render'}-time)` : undefined;
  const useCache = isOptionFunc ? optional('cacheRawTemplates') : optional.cacheRawTemplates;
  if (!useCache) {
    if (log &amp;&amp; log.info) {
      log.info(`CACHE: ↩️ Skipping memory write due to "options.cacheRawTemplates" is turned off for template "${name}" @ "${path}"${logLabel}`);
    }
    return;
  }
  data = data || '';
  const cacheName = forContent ? 'data' : 'sources';
  const isFetch = forContent &amp;&amp; isAbsName(name, optional);
  const dataType = typeof data, isContentJSON = forContent &amp;&amp; extension === 'json' &amp;&amp; dataType === 'object';
  const writable = isContentJSON ? data : dataType === 'function' &amp;&amp; ((isFetch &amp;&amp; name) || forContent) ? data.toString() : null;
  if (log.info) {
    log.info(`CACHE: ${isFetch ? '📡 HTTPS' : '🏧 MEMORY'}- Writting template ${forContent ? 'partial' : 'code'} `
    + `${isFetch ? `POST "${path}"` : `for "${name}" @ "${path}" to memory`}${logLabel}`);
  }
  if (writable &amp;&amp; isFetch) {
    await fetcher(mods, path, optional, params, store, writable, registrant.writeFormatter, true, log);
  } else if (writable &amp;&amp; !forContent &amp;&amp; typeof registrant.writeFormatter === 'function') {
    writable = registrant.writeFormatter(writable, opts.writeFormatOptions);
  }
  if (forContent) {
    await registrant.registerPartial(path, isContentJSON ? JSON.stringify(writable) : typeof writable !== 'string' ? params : writable, extension);
  } else {
    store[cacheName] = store[cacheName] || {};
    store[cacheName][path] = {
      name: path,
      shortName: name,
      func: dataType === 'function' ? writable || data : (new Function(`return ${writable || data}`))()
    };
    return store[cacheName][path].func;
  }
}

/**
 * Determines if a template name has an absolute path in it's name or can be converted to one
 * @private
 * @ignore
 * @param {String} name The template name that uniquely identifies the template content
 * @param {(TemplateOpts | Function(name:String):*)} optional Either the {@link TemplateOpts} or a function that takes a
 * single name argument and returns the option value
 * @returns {Boolean} `true` when the template name has an absolute path in it's name or can be converted to one
 */
function isAbsName(name, optional) {
  const isOptionFunc = typeof optional === 'function';
  const bypassExp = isOptionFunc ? optional('bypassUrlRegExp') : optional.bypassUrlRegExp;
  const hasBase = bypassExp &amp;&amp; name.match(bypassExp);
  if (hasBase) return true;
  const partialsURL = isOptionFunc ? optional('partialsURL') : optional.partialsURL;
  return !!partialsURL;
}

/**
 * Loads and/or sets all of the modules that will be used
 * @private
 * @ignore
 * @param {(TemplateOpts | Function(name:String):*)} optional Either the {@link TemplateOpts} or a function that takes a
 * single name argument and returns the option value
 * @returns {Object} The modules
 */
async function modules(optional) {
  const mods = {};
  if (typeof fetch === 'undefined') {
    const isOptionFunc = typeof optional === 'function';
    const cjs = isOptionFunc ? optional('useCommonJs') : optional.useCommonJs;
    mods.https = cjs ? require('https') : /* TODO : ESM use... await import('https')*/null;
  }
  return mods;
}

/**
 * GETs or POSTs data via `window.fetch` in the browser or using the `https` module on the server
 * @private
 * @ignore
 * @param {(String | URL)} [url] The URL to process 
 * @param {(TemplateOpts | Function(name:String):*)} optional Either the {@link TemplateOpts} or a function that takes a
 * single name argument and returns the option value
 * @param {(URLSearchParams | String)} [params] The URL parameters to use (JSON or URL encoded)
 * @param {Object} [store] The object where the template, partials and context are stored
 * @param {String} data The code block that will be written
 * @param {Function} [formatter] The function that will format written sources during include discovery (if any). The formatting function
 * takes 1 or 2 arguments with the first being the content that will be formatted and the second being
 * @param {Boolean} [close] Whether or not to close any resources when complete
 * @param {Object} [log] The log that can contain functions for each of the following: `error`/`warn`/`info`/`debug`.
 * @returns {(String | undefined)} The result or `undefined` when URL is omitted
 */
async function fetcher(mods, url, optional, params, store, data, formatter, close, log) {
  if (!url) return;
  const isOptionFunc = typeof optional === 'function';
  const encoding = isOptionFunc ? optional('encoding') : optional.encoding;
  url = url instanceof URL ? url : new URL(url);
  params = params instanceof URLSearchParams ? params : params ? new URLSearchParams(params) : null;
  const isDataJSON = data &amp;&amp; typeof data === 'object';
  data = isDataJSON ? JSON.stringify(data) : data &amp;&amp; data.toString();
  if (data &amp;&amp; typeof formatter === 'function') {
    const fopts = isOptionFunc ? optional('writeFormatOptions') : optional.writeFormatOptions;
    data = formatter(data, fopts);
  }
  const reqOptName = data ? 'writeFetchRequestOptions' : 'readFetchRequestOptions';
  const ropts = (isOptionFunc ? optional(reqOptName) : optional[reqOptName]) || {};
  ropts.method = (ropts.method &amp;&amp; ropts.method.toUpperCase()) || (data ? 'POST' : 'GET');
  ropts.credentials = ropts.credentials || 'same-origin';
  ropts.headers = ropts.headers || {};
  if (ropts.method !== 'GET') {
    // Content-Type needs to match the body
    if (isDataJSON) ropts.headers['Content-Type'] = `application/json; charset=${encoding}`;
    else if (data) ropts.headers['Content-Type'] = `text/javascript; charset=${encoding}`;
    else ropts.headers['Content-Type'] = `application/x-www-form-urlencoded; charset=${encoding}`;
    ropts.headers['Content-Length'] = Buffer.byteLength(data || (params &amp;&amp; params.toString())); // needs to match the body
  } else {
    ropts.headers['Content-Type'] = `text/html; charset=${encoding}`; // needs to match the body
  }
  if (ropts.method === 'GET' &amp;&amp; params) url.search = params;
  else if (data) ropts.body = data;
  else if (params) ropts.body = params.toString();
  const hasFetch = typeof fetch !== 'undefined';
  if (log &amp;&amp; (log.info || log.debug)) {
    (log.debug || log.info)(`CACHE: 📡 ${hasFetch ? 'fetch' : 'https.request'} ${ropts.method} "${url.toString()}"`
      + `${log.debug ? ` for ${JSON.stringify(ropts)}` : ''}`);
  }
  if (hasFetch) {
    const res = await fetch(new Request(url.toString()), ropts);
    if (!res.ok) {
      const err = new Error(`${res.status}: ${res.statusText || ''} &lt;- template content ${ropts.method} failed for: ${url}"`);
      if (log.error) log.error(err);
      throw err;
    }
    if (log &amp;&amp; (log.info || log.debug)) {
      (log.debug || log.info)(`CACHE: 📡 fetch ${ropts.method} "${url.toString()}" returned ${log.debug ? res.text() : res.ok ? 'OK' : 'Not OK'}`);
    }
    const rtn = res.text();
    if (!data &amp;&amp; ropts.method === 'GET' &amp;&amp; typeof formatter === 'function' &amp;&amp; typeof rtn === 'string') {
      const fopts = isOptionFunc ? optional('readFormatOptions') : optional.readFormatOptions;
      return formatter(rtn, fopts);
    }
    return rtn || '';
  }
  return new Promise(function httpsFetcher(resolve, reject) {
    const req = mods.https.request(url, ropts, res => {
      var data = '';
      if (res.statusCode &lt; 200 || res.statusCode > 299) {
        return reject(new Error(`${res.statusCode}: ${res.statusMessage || ''} &lt;- template content ${ropts.method} failed for: "${url}"`));
      }
      res.on('data', chunk => {
        data += chunk;
      });
      res.on('end', () => {
        if (log &amp;&amp; (log.info || log.debug)) {
          (log.debug || log.info)(`CACHE: 📡 https.request ${ropts.method} "${url.toString()}" returned ${log.debug ? data : 'OK'}`);
        }
        if (ropts.method === 'GET' &amp;&amp; typeof formatter === 'function' &amp;&amp; typeof data === 'string') {
          const ropts = isOptionFunc ? optional('readFormatOptions') : optional.readFormatOptions;
          resolve(formatter(data, ropts));
        } else resolve(data || '');
      });
    });
    req.on('error', err => {
      if (log &amp;&amp; log.error) log.error(err);
      reject(err);
    });
    if (ropts.method !== 'GET') req.write(data || (params &amp;&amp; params.toString()));
    req.end();
  });
}

/**
 * Generates the full name path for a given template or context name.
 * @private
 * @ignore
 * @param {Object} nmrs The naming functions container defined by {@link Cachier.readWriteNames}
 * @param {String} name The template name that uniquely identifies the template content
 * @param {(TemplateOpts | Function(name:String):*)} optional Either the {@link TemplateOpts} or a function that takes a
 * single name argument and returns the option value
 * @param {URLSearchParams} [params] Any search parameters to include in the full name
 * @param {Object} store The storage object that can contain metadata for naming operations
 * @param {Boolean} [forContent] `true` to read a template __content__, `false` to read the template source code
 * @param {String} [extension] The file extension designation (only used when `forContent` or `forContext` is truthy)
 * @param {String} [forContext] `true` to read a template __context__ (overrides `forContent`)
 * @returns {String} An name suitable for read/write operations
 */
async function readWriteName(nmrs, name, optional, params, store, forContent, extension, forContext) {
  if (!name) throw new ReferenceError('Template "name" is required');
  const isOptionFunc = typeof optional === 'function';
  forContext = forContext || (name === (isOptionFunc ? optional('defaultContextName') : optional.defaultContextName));
  const bypass = isOptionFunc ? optional('bypassUrlRegExp') : optional.bypassUrlRegExp;
  const isBypass = bypass &amp;&amp; name.match(bypass);
  let base = '';
  if (!isBypass) {
    let urlOptName = forContext ? 'contextURL' : 'partialsURL';
    if (!forContext) {
      const fileNameExp = isOptionFunc ? optional('filename') : optional.filename;
      let fileName = fileNameExp &amp;&amp; name.match(fileNameExp);
      fileName = fileName &amp;&amp; fileName[2];
      if (fileName) {
        const tname = isOptionFunc ? optional('defaultTemplateName') : optional.defaultTemplateName;
        if (tname ===  fileName) urlOptName = 'templateURL';
      }
    }
    base = (isOptionFunc ? optional(urlOptName) : optional[urlOptName]) || '';
    base = base ? `${base}${base.endsWith('/') ? '' : '/'}` : '';
  }
  let ext;
  const isAbs = /^https?:\/?\/?/i.test(name);
  // use pseudo origin when not absolute in order to parse URL parts (removed later)
  const url = new URL(isAbs ? name : `http://example.com/${name}`), extRx = /\.([0-9a-z]+)(?:[\?#]|$)/i;
  if (extRx.test(url.pathname)) {
    ext = ''; // already has extension
  } else if (forContent || forContext) {
    if (typeof extension === 'string') {
      ext = extension;
    } else if (forContext) {
      ext = (isOptionFunc ? optional('defaultContextExtension') : optional.defaultContextExtension) || '';
    } else {
      ext = (isOptionFunc ? optional('defaultExtension') : optional.defaultExtension) || '';
    }
  } else {
    ext = isOptionFunc ? optional('useCommonJs') : optional.useCommonJs ? 'js' : 'mjs';
  }
  if (ext) {
    ext = `${extRx.test(ext) ? '' : '.'}${ext}`;
  }
  let realName = name;
  if (ext) {
    url.pathname = `${url.pathname}${ext}`;
    realName = url.toString();
    if (!isAbs) realName = realName.replace(`${url.origin}/`, '');
  }
  return `${base}${realName}${params instanceof URLSearchParams ? `?${params.toString()}` : ''}`;
}

/**
 * Creates a pseudo registrant
 * @private
 * @ignore
 * @param {String} path The path to the template that will be written
 * @param {(TemplateOpts | Function(name:String):*)} optional Either the {@link TemplateOpts} or a function that takes a
 * single name argument and returns the option value
 * @param {Object} store Where the new cache will be stored
 * @param {Function} readFormatter The read formatter
 * @param {Function} writeFormatter The write formatter
 */
function initRegistrant(path, optional, store, readFormatter, writeFormatter) {
  const reg = {
    registerPartial: async (name, content, extension) => {
      store.data[path] = {
        name: path,
        shortName: name,
        content,
        extension: extension || (typeof optional === 'function' ? optional('defaultExtension') : optional.defaultExtension)
      };
    },
    unregister: name => {
      return Promise.resolve([delete store.data[path], delete store.sources[path]]);
    }
  };
  if (readFormatter) reg.readFormatter = readFormatter;
  if (writeFormatter) reg.writeFormatter = writeFormatter;
  return reg;
}

/**
 * Initializes the cache on a given store
 * @private
 * @ignore
 * @param {Object} store Where the new cache will be stored
 * @returns {Object} The cache object
 */
function initCache(store) {
  store.data = {};
  store.sources = {};
  store.helpers = new Director();
}

// private mapping substitute until the following is adopted: https://github.com/tc39/proposal-class-fields#private-fields
let map = new WeakMap();
let internal = function(object) {
  if (!map.has(object)) map.set(object, {});
  return {
    at: map.get(object),
    this: object
  };
};

// NOTE : WeakMap may cause issues when garbage collected on old versions of Node
// static internal(obj) {
//   if (!obj._data) {
//     Object.defineProperty(obj, '_data', { value: {}, writable: false });
//     Object.defineProperty(obj._data, 'at', { value: {}, writable: false });
//     Object.defineProperty(obj._data, 'this', { value: obj, writable: false });
//   }
//   return obj._data;
// }</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<div id="jsdocpChangelogContent" data-title="CHANGELOG v1.0.0">
  <svg class="jsdocp-close" id="jsdocpChangelogClose" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
  </svg>
  <h2><a href="https://github.com/ugate/templeo/tree/v1.0.0">1.0.0</a> (2019-12-16)</h2>
<p><a href="https://github.com/ugate/templeo/compare/v1.0.0...v1.0.0">Full Changelog</a></p>
</div>



<script src="jsdocp/scripts/index.js"></script></body>
</html>
